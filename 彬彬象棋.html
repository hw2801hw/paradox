<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>中國象棋 | 基本/技能/說明模式（AI強化版）</title>
  <style>
    :root{
      --bg: #faf7f2;
      --panel: #ffffffcc;
      --ink: #222;
      --muted: #666;
      --red: #c0392b;
      --black: #222;
      --grid: #333;
      --river: #f1e9dd;
      --hint-red: #ff4d4f;
      --hint-black: #111;
      --sel: #3498db;
      --danger: #e74c3c;
      --piece-fill: #fff7e8;
      --piece-stroke: #111;
      --shadow: 0 10px 20px rgba(0,0,0,.15);
      --orange:#ff7a00;
      --gray:#7a7a7a;
      --fx1: #c4b5fd;
      --fx2: #a78bfa;
      --fx3: #60a5fa;
      --fx4: #f59e0b;
      --blue:#1565ff;
      --green:#2ecc71;
      --greenDim: rgba(46, 204, 113, 0.28);
      /* 類別邊框色彩 */
      --skill-s-color: #e67e22; /* 兵/卒 Orange */
      --skill-k-color: #3498db; /* 將/帥 Blue */
      --skill-c-color: #e74c3c; /* 炮/砲 Red */
      --skill-r-color: #9b59b6; /* 車/俥 Purple */
      --skill-h-color: #1abc9c; /* 馬 Teal */
      --skill-e-color: #f1c40f; /* 象/相 Yellow */
      --skill-a-color: #34495e; /* 士/仕 Slate */
      --skill-b-color: #8e44ad; /* 鏢/鑣 Purple */
      --poison-mist-color: rgba(142, 68, 173, 0.4); /* 毒霧紫色 */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(180deg,#f8f4ee,#f3efe7);
      color:var(--ink);
      font:16px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans","PingFang TC","Heiti TC","Microsoft JhengHei",Arial,sans-serif;
      display:flex;flex-direction:column;align-items:center;
    }
    button{
      appearance:none;border:1px solid #ddd;background:#fff;color:var(--ink);
      padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700;transition:.15s ease;box-shadow:0 1px 2px rgba(0,0,0,.06)
    }
    button:hover{transform:translateY(-1px)}
    button:active{transform:translateY(0)}
    button[disabled]{opacity:.5;cursor:not-allowed;transform:none}
    .chip{border:none;background:#f6f3ee;color:var(--muted);font-weight:700;padding:8px 10px;border-radius:10px}
    header{width:100%;max-width:1100px;padding:12px 16px;display:flex;flex-wrap:wrap;align-items:center;gap:8px 12px}
    h1{font-size:20px;margin:0;font-weight:800;letter-spacing:.5px}
    .spacer{flex:1}
    #home{width:100%;max-width:1100px;margin:18px auto;padding:16px;}
    .hero{background:radial-gradient(1200px 400px at 10% -10%, #fff, #f8f4ee);border-radius:18px;box-shadow:var(--shadow);padding:24px;display:flex;flex-direction:column;gap:14px}
    .tabs{display:flex;gap:8px;margin:10px 0;flex-wrap:wrap}
    .tab{padding:8px 12px;border-radius:999px;border:2px solid #eee;background:#fff;font-weight:800}
    .tab.active{border-color:var(--blue);color:var(--blue);background:#f3f7ff}
    .modes{display:grid;grid-template-columns: repeat(2, minmax(0,1fr));gap:12px;margin-top:8px}
    .modebtn{display:flex;flex-direction:column;align-items:flex-start;gap:10px;padding:16px;border:2px solid #eee;border-radius:14px;background:#fff;box-shadow:var(--shadow);transition:.2s ease}
    .modebtn:hover{transform:translateY(-2px);border-color:#ddd}
    .modebtn strong{font-size:18px}
    .modebtn span{color:#666}
    .aiopts,.skillgrid{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .radio{display:inline-flex;gap:6px;align-items:center;background:#fff;border:1px solid #eee;border-radius:999px;padding:6px 10px;font-weight:700}
    .radio input{width:16px;height:16px}
    .skillgrid{display:grid;grid-template-columns: repeat(4, minmax(0,1fr));gap:10px;width:100%}
    .skillcard{border:2px solid #eee;border-radius:12px;padding:10px;background:#fff;display:flex;flex-direction:column;gap:6px;min-height:86px;justify-content:center}
    .skillcard .title{font-weight:900}
    .skillcard .desc{display:none}
    .skillcard.disabled{opacity:.5}
    .skillcard input{margin-right:6px}
    @media (max-width:820px){ .modes{grid-template-columns:1fr} .skillgrid{grid-template-columns: repeat(2, minmax(0,1fr));} }

    #app{width:100%;display:none}
    .panel{width:100%;max-width:1100px;background:var(--panel);backdrop-filter: blur(6px);border-radius:14px;box-shadow:var(--shadow);padding:10px 12px;display:flex;flex-wrap:wrap;gap:8px 10px;align-items:center;justify-content:space-between;}
    .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .turn{padding:6px 10px;border-radius:999px;background:#fff;border:1px solid #eee}
    .turn.red{color:var(--red)}
    .turn.black{color:var(--black)}
    .msg{font-weight:800}
    .msg.check{color:var(--danger)}
    .msg.mate{color:#fff;background:var(--danger);padding:6px 10px;border-radius:8px}
    .msg.draw{color:#fff;background:#888;padding:6px 10px;border-radius:8px}
    .badge{padding:4px 8px;border-radius:999px;background:#eef3ff;color:var(--blue);font-weight:900;font-size:12px}

    .board-wrap{width:100%;max-width:1100px;margin:10px auto 12px;border-radius:16px;background:#fff;box-shadow:var(--shadow);padding:10px}
    svg#board{width:100%;height:auto;display:block;touch-action:manipulation;user-select:none;-webkit-tap-highlight-color: transparent;}
    .under{fill:none;stroke:var(--grid);stroke-width:2.5;shape-rendering:crispEdges}
    .river{fill:var(--river)}
    .palace{stroke:var(--grid);stroke-width:2.5}
    .coords text{fill:#999;font-size:18px}
    .piece{cursor:pointer}
    .piece.ghost { opacity: 0.6; }
    .piece circle{fill:var(--piece-fill);stroke:var(--piece-stroke);stroke-width:2.4;filter: drop-shadow(0 2px 1px rgba(0,0,0,.15));transition: stroke .2s ease, stroke-width .2s ease;}
    .piece.red circle{stroke:var(--red)}
    .piece.black circle{stroke:var(--black)}
    /* 技能類別邊框樣式 */
    .skill-S circle { stroke: var(--skill-s-color); stroke-width: 4.5; }
    .skill-K circle { stroke: var(--skill-k-color); stroke-width: 4.5; }
    .skill-C circle { stroke: var(--skill-c-color); stroke-width: 4.5; }
    .skill-R circle { stroke: var(--skill-r-color); stroke-width: 4.5; }
    .skill-H circle { stroke: var(--skill-h-color); stroke-width: 4.5; }
    .skill-E circle { stroke: var(--skill-e-color); stroke-width: 4.5; }
    .skill-A circle { stroke: var(--skill-a-color); stroke-width: 4.5; }
    .skill-B circle { stroke: var(--skill-b-color); stroke-width: 4.5; }

    .piece text{font-weight:900;font-size:38px;dominant-baseline: middle;text-anchor: middle;pointer-events:none}
    .piece.red text{fill:var(--red)}
    .piece.black text{fill:var(--black)}
    .sel{fill:none;stroke:var(--sel);stroke-width:5;stroke-dasharray:6 4}
    .incheck{fill:none;stroke:var(--danger);stroke-width:5}
    .startFillRed{fill:var(--orange); opacity:.32}
    .startFillBlack{fill:var(--gray); opacity:.28}
    .endStroke{fill:none; stroke:var(--sel); stroke-width:6; opacity:.95}
    .hint-red{fill:var(--hint-red); opacity:.45}
    .hint-black{fill:var(--hint-black); opacity:.45}
    .hint-cap{opacity:.6}

    .vanishMark{fill: var(--greenDim); stroke: var(--green); stroke-width: 4}
    .poisonMist{fill: var(--poison-mist-color); stroke-width: 4; stroke-dasharray: 8 4;}
    .poisonMist.mist-r { stroke: var(--red); }
    .poisonMist.mist-b { stroke: var(--black); }


    .kfx-glow{fill:url(#kingGlowGrad); opacity:.95; filter: blur(12px); animation:kfxGlow 1200ms ease-out both;}
    @keyframes kfxGlow{0%{opacity:0; transform:scale(0.85)} 40%{opacity:.95; transform:scale(1.03)} 100%{opacity:0; transform:scale(1.25)}}
    .kfx-ring{fill:none; stroke:var(--fx2); stroke-width:12; opacity:.9; stroke-dasharray: 6 8; animation:kfxRing 1100ms ease-out both;}
    @keyframes kfxRing{0%{opacity:1; stroke-width:16; transform:scale(0.6)} 70%{opacity:.9} 100%{opacity:0; stroke-width:2; transform:scale(1.45)}}
    .kfx-ring2{stroke:var(--fx1)}
    .kfx-star{fill:var(--fx4); opacity:0; animation:kfxStar 950ms ease-out both;}
    @keyframes kfxStar{0%{opacity:0; transform:scale(.5)} 35%{opacity:1; transform:scale(1.1)} 100%{opacity:0; transform:scale(1.5)}}

    .legend{width:100%;max-width:1100px;color:#555;padding: 4px 12px 14px;font-size:14px}
    .legend .skillNote{display:none}
    .legend.skill .skillNote{display:none}

    .moves{width:100%;max-width:1100px;background:#fff;box-shadow:var(--shadow);border-radius:14px;padding:10px 12px;margin:0 0 24px 0;}
    .moves h3{margin:6px 2px 8px;font-size:16px}
    .movelist{display:grid;grid-template-columns: repeat(2, minmax(0,1fr));gap:6px 10px;max-height:220px;overflow:auto;padding-right:6px}
    .moveline{display:flex;gap:8px;align-items:center}
    .moveline .idx{color:#999;width:28px;text-align:right}
    .moveline .mv{font-weight:700}
    @media (max-width:520px){ .movelist{grid-template-columns: 1fr} }

    .skills{width:100%;max-width:1100px;background:#fff;box-shadow:var(--shadow);border-radius:14px;padding:10px 12px;margin:0 0 12px 0;display:flex;flex-wrap:wrap;gap:10px 12px;align-items:center;justify-content:space-between;}
    .skills .left{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .skills .tag{padding:6px 10px;border-radius:10px;background:#f6f7fb;border:1px solid #e8ecff;font-weight:900;color:#2a52c4}
    .skills .progress{display:flex;gap:14px;align-items:center;flex-wrap:wrap}
    .skills .bar{width:220px;height:10px;border-radius:999px;background:#eee;overflow:hidden}
    .skills .bar > span{display:block;height:100%;background:#1565ff;width:0%}
    .skills .meta{color:#666;font-weight:800}
    .pill{padding:6px 10px;border-radius:999px;background:#eef3ff;color:#1565ff;font-weight:900}
    .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:14px;background:#111;color:#fff;padding:10px 12px;border-radius:12px;box-shadow: 0 8px 20px rgba(0,0,0,.25);font-weight:900;opacity:0;pointer-events:none;transition:.25s ease;z-index:20}
    .toast.show{opacity:1;bottom:20px}

    #guide{width:100%;max-width:1100px;display:none}
    .guide-wrap{background:#fff;border-radius:16px;box-shadow:var(--shadow);padding:16px}
    .guide-grid{display:grid;grid-template-columns: repeat(2, minmax(0,1fr));gap:14px}
    .gcard{border:2px solid #eee;border-radius:12px;padding:14px}
    .gcard h4{margin:0 0 8px 0}
    .gcard p{margin:6px 0;color:#555}
    @media (max-width:820px){ .guide-grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <header>
    <h1>彬彬象棋</h1>
    <div class="spacer"></div>
    <span id="modeChip" class="chip">請選擇彬彬模式</span>
  </header>

  <main id="home">
    <div class="hero">
      <h2>選擇彬彬模式</h2>
      <div class="tabs">
        <button id="tabBasic" class="tab active">基本模式</button>
        <button id="tabSkill" class="tab">技能模式</button>
        <button id="tabGuide" class="tab">說明模式</button>
      </div>

      <div id="basicPane">
        <div class="modes">
          <button id="basicLocal" class="modebtn">
            <strong>本地對決</strong>
            <span>雙人同機 · 交替落子</span>
          </button>
          <div class="modebtn">
            <strong>AI對決</strong>
            <span>選擇先手與難度</span>
            <div class="aiopts">
              <label class="radio"><input type="radio" name="basicFirst" value="human" checked> 你先手（紅）</label>
              <label class="radio"><input type="radio" name="basicFirst" value="ai"> AI先手（黑）</label>
            </div>
            <div class="aiopts" style="margin-top: 8px;">
              <label class="radio"><input type="radio" name="basicDifficulty" value="novice" checked> 新手難度</label>
              <label class="radio"><input type="radio" name="basicDifficulty" value="veteran"> 老手難度</label>
            </div>
            <button id="basicAI">開始AI對決</button>
          </div>
        </div>
      </div>

      <div id="skillPane" style="display:none">
        <div class="modes">
          <div class="modebtn">
            <strong>技能模式 · 本地對決</strong>
            <span>玩家1 與 玩家2 各選 1 類別</span>
            <div class="skillgrid" id="p1Skills"></div>
            <div class="skillgrid" id="p2Skills" style="margin-top:8px"></div>
            <button id="skillLocalStart">開始</button>
          </div>
          <div class="modebtn">
            <strong>技能模式 · AI對決</strong>
            <span>你選類別，AI 自動同類別</span>
            <div id="aiSkillGrid" class="skillgrid"></div>
            <div class="aiopts" style="margin-top:8px">
              <label class="radio"><input type="radio" name="skillFirst" value="human" checked> 你先手（紅）</label>
              <label class="radio"><input type="radio" name="skillFirst" value="ai"> AI先手（黑）</label>
            </div>
            <div class="aiopts" style="margin-top: 8px;">
              <label class="radio"><input type="radio" name="skillDifficulty" value="novice" checked> 新手難度</label>
              <label class="radio"><input type="radio" name="skillDifficulty" value="veteran"> 老手難度</label>
            </div>
            <button id="skillAIStart">開始AI對決</button>
          </div>
        </div>
      </div>

      <div id="guidePane" style="display:none">
        <div class="guide-wrap">
          <h3>說明模式</h3>
          <p>此模式僅提供規則與技能解說，沒有任何對決或互動棋盤。請回到基本或技能模式開始對弈。</p>
          <div class="guide-grid">
            <div class="gcard">
              <h4>技能模式總覽</h4>
              <p>被動：依類別而定；目前開放「兵/卒」、「將/帥」、「炮/砲」、「象/相」、「士/仕」與「鏢/鑣」。</p>
              <p>同一回合只能使用一個技能；施放時会隐藏其餘技能按鈕，回合結束後再恢復。</p>
              <p>將/帥不可被吃（絕對不死）；若你選擇「將/帥」類別，將/帥可無視將軍與九宮限制。</p>
            </div>
            <div class="gcard">
              <h4>兵/卒 類別</h4>
              <p>被動（僅技能模式）：四向一步。</p>
              <p>A技：三步登天；B技：指敵為友；必殺技：進化成王。</p>
            </div>
            <div class="gcard">
              <h4>將/帥 類別</h4>
              <p>被動：絕對不死；可走全場四向一步；無視將軍。</p>
              <p>A技：草叢陷阱（用綠框標記3枚敵子(將/帥除外)，敵方回合結束時，仍在原格的敵棋將會消失）。</p>
              <p>B技：替身司令（選擇一枚敵子(將/帥除外)使其消失，我方將/帥瞬移至該位置）。</p>
              <p>必殺技：臣下凡仙（在K周圍八格生成臣，覆蓋非敵K的所有子）。</p>
            </div>
             <div class="gcard">
              <h4>炮/砲 類別</h4>
              <p>被動：可對角隔一子炮吃。</p>
              <p>A技：驚不驚喜 (隨機5枚我方棋子變為砲/炮，持續一回合)。</p>
              <p>B技：意不意外 (選一枚敵子，使其周圍八格的棋子消失，敵將/帥除外)。</p>
              <p>必殺技：槍砲有眼 (己方剩一枚炮/砲時解鎖。在敵方場地生成毒霧，敵棋進入即消失，毒霧每兩回合增加一個)。</p>
            </div>
            <div class="gcard">
              <h4>象/相 類別</h4>
              <p>被動：若對方選擇「將/帥」類別，會使它「失去不死」的能力。</p>
              <p>A技：事功半倍 (解鎖50%必殺技條件)。</p>
              <p>B技：功半事倍 (解鎖50%必殺技條件)。</p>
              <p>必殺技：丞臨天下 (己方象/相變為「丞」，使己方全體棋子可額外走周圍八格，直到所有「丞」被消滅)。</p>
            </div>
            <div class="gcard">
              <h4>士/仕 類別</h4>
              <p>被動：使敵方的「君」不能吃己方的「仕/士」。</p>
              <p>A技：井底之土（己方的「仕/士」可出宮，並且不受半場限制直到對局結束）。</p>
              <p>B技：聽天仕命（敵方除了「將/帥」的棋外，其餘的棋都不能再進入敵我雙方的「九宮格」內，直到對局完結）。</p>
              <p>必殺技：君辱神亡（敵方的「仕/士」行動一步後解鎖。立即使敵方全體棋子(除了「將/帥」和敵方所選類別外)都變成「君」）。</p>
            </div>
            <div class="gcard">
              <h4>鏢/鑣 特別類別</h4>
              <p>被動：己方士/仕消失，於九宮中心生成「鑣」，無法移動。被己方「幽靈帥」吃後，會在隨機空白位置生成24枚己方「帥」。</p>
              <p>A技：智取滅亡（跳過5回合解鎖）。己方棋子消失（帥除外），帥變為「幽靈帥」並傳送至敵方九宮，此時帥的價值視為11枚棋。</p>
              <p>B技：棄車保卒（跳過5回合解鎖）。強製使敵方的下一回合只能行動「帥/將」。</p>
              <p>必殺技：無法無天（開局解鎖）。大幅增加敵方技能解鎖難度，或禁用/偷取敵方已使用的必殺技效果。</p>
              <p>特殊規則：己方棋子數剩下10枚或以下則**立即戰敗**。</p>
            </div>
            <div class="gcard">
              <h4>王/丞/君/鑣 行動特性</h4>
              <p>王：將/士/象/馬步型 + 直線/對角隔一子「炮吃」；不受九宮/半場限制。</p>
               <p>丞：賦予全隊額外移動能力的光環型棋子，自身移動方式同「象/相」。</p>
               <p>君：可斜走一至三格，但不能跳躍棋子。</p>
               <p>鑣：特殊棋子，被動效果核心，無法移動。</p>
            </div>
          </div>
        </div>
      </div>

    </div>
  </main>

  <div id="guide" aria-hidden="true"></div>

  <div id="app">
    <div class="panel">
      <div class="controls">
        <button id="homeBtn">返回主頁</button>
        <button id="newBtn">新局</button>
        <button id="undoBtn">悔棋</button>
        <button id="skipBtn" style="display: none;">跳過回合</button>
        <label><input type="checkbox" id="coordTgl" checked> 顯示座標</label>
      </div>
      <div class="right">
        <span id="turnBadge" class="turn red">輪到：紅方</span>
        <span id="statusMsg" class="msg"></span>
        <span id="actionBadge" class="badge" style="display:none"></span>
      </div>
    </div>

    <div id="skillBar" class="skills" style="display:none">
      <div class="left">
        <span id="skillTag" class="tag">類別：兵/卒</span>
        <div class="progress">
          <span class="pill">絕招進度（依類別）</span>
          <div class="bar"><span id="progBar"></span></div>
          <span id="progMeta" class="meta">0%（0/5）</span>
        </div>
        <div class="progress">
          <span class="pill">必殺技</span>
          <div class="bar"><span id="ultraBar"></span></div>
          <span id="ultraMeta" class="meta">未解鎖</span>
        </div>
      </div>
      <div class="right">
        <button id="btnA" disabled>A技</button>
        <button id="btnB" disabled>B技</button>
        <button id="btnUltra" disabled>必殺技</button>
      </div>
    </div>

    <div class="board-wrap">
      <svg id="board" viewBox="0 0 900 1000" aria-label="中國象棋棋盤" role="img">
        <defs>
          <radialGradient id="gPiece" cx="30%" cy="30%" r="70%">
            <stop offset="0%" stop-color="#fffef8"/>
            <stop offset="100%" stop-color="#f0e5ce"/>
          </radialGradient>
          <radialGradient id="kingGlowGrad" cx="50%" cy="50%" r="60%">
            <stop offset="0%" stop-color="#e9d5ff"/>
            <stop offset="100%" stop-color="#c4b5fd"/>
          </radialGradient>
        </defs>
        <g id="grid"></g>
        <g id="marks"></g>
        <g id="hl"></g>
        <g id="pieces"></g>
        <g id="overlay"></g>
      </svg>
    </div>

    <div class="legend" id="legendText">
      <div>提示：紅點=紅方可走；黑點=黑方可走；起步格橘/灰；落點藍框。</div>
      <div class="skillNote"></div>
    </div>

    <div class="moves">
      <h3>著法記錄</h3>
      <div id="movelist" class="movelist" aria-live="polite"></div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    // ===== Config =====
    const BOARD_WIDTH = 9, BOARD_HEIGHT = 10, CELL = 100;
    const PIECE_VALUE = { K:1000, R:9, C:5, H:4, E:2, A:2, S:1, W:12, M:6, X:3, U:3, B:0 };
    const CLASSES = ['兵/卒','將/帥','炮/砲', '象/相', '士/仕', '鏢/鑣', '車/俥','馬'];
    const CLASS_KEY = { '兵/卒':'S', '將/帥':'K', '炮/砲':'C', '車/俥':'R', '馬':'H', '象/相':'E', '士/仕':'A', '鏢/鑣':'B' };
    const SUPPORT_CLASS = new Set(['兵/卒','將/帥', '炮/砲', '象/相', '士/仕', '鏢/鑣']);

    const AI_TIMEOUT_MS = 3000;
    const AI_PAWN_FAST_CHARGE = true;

    // ===== DOM =====
    const boardEl = document.getElementById('board');
    const gridEl = document.getElementById('grid');
    const marksEl = document.getElementById('marks');
    const piecesEl = document.getElementById('pieces');
    const hlEl = document.getElementById('hl');
    const overlayEl = document.getElementById('overlay');
    const turnBadge = document.getElementById('turnBadge');
    const statusMsg = document.getElementById('statusMsg');
    const coordTgl = document.getElementById('coordTgl');
    const movelistEl = document.getElementById('movelist');
    const modeChip = document.getElementById('modeChip');
    const actionBadge = document.getElementById('actionBadge');
    const skipBtn = document.getElementById('skipBtn');

    const homeView = document.getElementById('home');
    const appView = document.getElementById('app');
    const guideView = document.getElementById('guide');
    const homeBtn = document.getElementById('homeBtn');
    const newBtn = document.getElementById('newBtn');
    const undoBtn = document.getElementById('undoBtn');
    const tabBasic = document.getElementById('tabBasic');
    const tabSkill = document.getElementById('tabSkill');
    const tabGuide = document.getElementById('tabGuide');
    const basicPane = document.getElementById('basicPane');
    const skillPane = document.getElementById('skillPane');
    const guidePane = document.getElementById('guidePane');
    const basicLocal = document.getElementById('basicLocal');
    const basicAI = document.getElementById('basicAI');
    const p1Skills = document.getElementById('p1Skills');
    const p2Skills = document.getElementById('p2Skills');
    const aiSkillGrid = document.getElementById('aiSkillGrid');
    const skillLocalStart = document.getElementById('skillLocalStart');
    const skillAIStart = document.getElementById('skillAIStart');

    const skillBar = document.getElementById('skillBar');
    const skillTag = document.getElementById('skillTag');
    const progBar = document.getElementById('progBar');
    const progMeta = document.getElementById('progMeta');
    const ultraBar = document.getElementById('ultraBar');
    const ultraMeta = document.getElementById('ultraMeta');
    const btnA = document.getElementById('btnA');
    const btnB = document.getElementById('btnB');
    const btnUltra = document.getElementById('btnUltra');
    const legendEl = document.getElementById('legendText');
    const toastEl = document.getElementById('toast');

    const pieceChar = {
      r: {K:'帥', A:'仕', E:'相', H:'馬', R:'俥', C:'炮', S:'兵', W:'王', M:'臣', X:'丞', U:'君', B:'鏢'},
      b: {K:'將', A:'士', E:'象', H:'馬', R:'車', C:'砲', S:'卒', W:'王', M:'臣', X:'丞', U:'君', B:'鑣'}
    };

    // ===== Start Position =====
    const START = (()=> {
      const empty = Array.from({length:BOARD_HEIGHT}, () => Array(BOARD_WIDTH).fill(null));
      const place = (x,y,c,t)=> empty[y][x]={c,t,id:Math.random().toString(36).slice(2)};
      // Black
      place(0,0,'b','R'); place(8,0,'b','R');
      place(1,0,'b','H'); place(7,0,'b','H');
      place(2,0,'b','E'); place(6,0,'b','E');
      place(3,0,'b','A'); place(5,0,'b','A');
      place(4,0,'b','K');
      place(1,2,'b','C'); place(7,2,'b','C');
      [0,2,4,6,8].forEach(x=> place(x,3,'b','S'));
      // Red
      place(0,9,'r','R'); place(8,9,'r','R');
      place(1,9,'r','H'); place(7,9,'r','H');
      place(2,9,'r','E'); place(6,9,'r','E');
      place(3,9,'r','A'); place(5,9,'r','A');
      place(4,9,'r','K');
      place(1,7,'r','C'); place(7,7,'r','C');
      [0,2,4,6,8].forEach(x=> place(x,6,'r','S'));
      return empty;
    })();

    // ===== State =====
    let state = {
      board: deepClone(START),
      turn: 'r',
      turnCount: 0,
      selected: null,
      legal: [],
      lastMove: null,
      lastStart: null,
      lastEnd: null,
      history: [],
      over: false,
      showCoords: true,
      gameMode: 'basic',
      playMode: null,
      aiSide: null,
      aiDifficulty: 'novice',
      skillChoice: { r: null, b: null },
      skill: { r: newSkillState(), b: newSkillState() },
      grass: [], 
      poisonMistInfo: [],
      tempCannonTransforms: [],
      chancellorActive: { r: false, b: false },
      advisorCanLeavePalace: { r: false, b: false },
      palaceRestrictionFor: null,
      isGhost: { r: false, b: false },
      forceKingMoveFor: null,
      pawnLossCount: { r:0, b:0 },
      aiBusy: false,
      aiTimeoutHandle: null
    };

    function newSkillState(){
      return {
        classKey:null, 
        progK:0, unlockAK:false, unlockBK:false,
        progS:0, unlockAS:false, unlockBS:false,
        progC:0, unlockAC:false, unlockBC:false,
        progE:0, unlockAE:false, unlockBE:false,
        progA:0, unlockAA:false, unlockBA:false,
        progB:0, unlockAB:false, unlockBB:false, // For Biao
        progMax:5,
        usedA:false, usedB:false,
        phase:'normal',
        aLock:null, aStepsLeft:0,
        bTarget:null,
        ultraUnlocked:false, ultraUsed:false,
        lastPawnDeath:null,
        skillLockForThisTurn:false,
        ultraStealState: null, // for Biao
      };
    }

    // ===== Utilities =====
    function deepClone(b){ return b.map(row => row.map(cell => cell ? {...cell} : null)); }
    function inside(x,y){ return x>=0 && x<BOARD_WIDTH && y>=0 && y<BOARD_HEIGHT; }
    function opposite(c){ return c==='r'?'b':'r'; }
    function palace(x,y,c){ return c==='r' ? (x>=3&&x<=5&&y>=7&&y<=9) : (x>=3&&x<=5&&y>=0&&y<=2); }
    function anyPalace(x,y) { return palace(x,y,'r') || palace(x,y,'b'); }
    function onOwnSide(y,c){ return c==='r' ? y>=5 : y<=4; }
    function findGeneral(b,c){ for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){ const p=b[y][x]; if(p&&p.c===c&&p.t==='K') return {x,y}; } return null; }
    function pathClear(b, x1,y1, x2,y2){
      if(x1===x2){ const [a,bm]=y1<y2?[y1,y2]:[y2,y1]; for(let y=a+1;y<bm;y++){ if(b[y][x1]) return false; } return true; }
      if(y1===y2){ const [a,bm]=x1<x2?[x1,x2]:[x2,x1]; for(let x=a+1;x<bm;x++){ if(b[y1][x]) return false; } return true; }
      return false;
    }
    function countBetween(b, x1,y1, x2,y2){
      let cnt=0;
      if(x1===x2){ const [a,bm]=y1<y2?[y1,y2]:[y2,y1]; for(let y=a+1;y<bm;y++){ if(b[y][x1]) cnt++; } }
      else if(y1===y2){ const [a,bm]=x1<x2?[x1,x2]:[x2,x1]; for(let x=a+1;x<bm;x++){ if(b[y1][x]) cnt++; } }
      else return Infinity;
      return cnt;
    }
    function countBetweenWithDiag(b, x1,y1, x2,y2){
      if(!(Math.abs(x2-x1)===Math.abs(y2-y1))) return Infinity;
      let cnt=0;
      const sx = Math.sign(x2-x1), sy = Math.sign(y2-y1);
      let x=x1+sx, y=y1+sy;
      while(x!==x2 || y!==y2){
        if(inside(x,y) && b[y][x]) cnt++;
        x+=sx; y+=sy;
      }
      return cnt;
    }
    function generalsFace(b){
      const rk=findGeneral(b,'r');
      const bk=findGeneral(b,'b');
      if(!rk || !bk) return false;
      if(rk.x!==bk.x) return false;
      return countBetween(b, rk.x, rk.y, bk.x, bk.y)===0;
    }
    function isSquareAttackedBy(b, tx,ty, by){
      for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){
        const p=b[y][x]; if(!p||p.c!==by) continue;
        const dx=tx-x, dy=ty-y;
        switch(p.t){
          case 'R': if(dx===0||dy===0){ if(pathClear(b,x,y,tx,ty)) return true; } break;
          case 'C': {
            if(dx===0||dy===0){ if(countBetween(b,x,y,tx,ty)===1) return true; }
            if(state.gameMode==='skill' && state.skill[p.c]?.classKey==='C'){
               if(Math.abs(dx)===Math.abs(dy) && countBetweenWithDiag(b,x,y,tx,ty)===1) return true;
            }
            break;
          }
          case 'H': {
            const kx=Math.abs(dx), ky=Math.abs(dy);
            if((kx===2&&ky===1)||(kx===1&&ky===2)){
              const lx=x+Math.sign(dx)*(kx===2?1:0);
              const ly=y+Math.sign(dy)*(Math.abs(dy)===2?1:0);
              if(!b[ly][lx]) return true;
            } break; }
          case 'E': if(Math.abs(dx)===2&&Math.abs(dy)===2){ if(onOwnSide(ty,by)===onOwnSide(y,by)){ const mx=x+dx/2,my=y+dy/2; if(!b[my][mx]) return true; } } break;
          case 'A': if(Math.abs(dx)===1&&Math.abs(dy)===1&&palace(tx,ty,by)) return true; break;
          case 'K': if(Math.abs(dx)+Math.abs(dy)===1) return true; break;
          case 'S': if(Math.abs(dx)+Math.abs(dy)===1) return true; break;
          case 'M':
            if(Math.abs(dx)===1 && Math.abs(dy)===1) return true;
            if(Math.abs(dx)===2 && Math.abs(dy)===2){
              const mx=x+dx/2, my=y+dy/2;
              if(!b[my][mx]) return true;
            }
            break;
          case 'W': if(canKingReachForAttack(b,x,y,tx,ty)) return true; break;
          case 'U': {
            if(Math.abs(dx) === Math.abs(dy) && Math.abs(dx) > 0 && Math.abs(dx) <= 3){
                let blocked = false;
                for(let i=1; i < Math.abs(dx); i++){
                    if(b[y + i * Math.sign(dy)][x + i * Math.sign(dx)]) {
                        blocked = true;
                        break;
                    }
                }
                if(!blocked) return true;
            }
            break;
          }
        }
      }
      return false;
    }
    function inCheck(b,c){ 
      if(state.skill[c]?.classKey === 'B') return false;
      const k=findGeneral(b,c); if(!k) return false; 
      return isSquareAttackedBy(b,k.x,k.y, opposite(c)); 
    }

    // King (W) attack reach helper
    function canKingReachForAttack(b, x,y, tx,ty){
      const dx = tx - x, dy = ty - y;
      const adx = Math.abs(dx), ady = Math.abs(dy);
      if((adx+ady)===1) return true;
      if(adx===1 && ady===1) return true;
      if(adx===2 && ady===2){
        const mx = x + dx/2, my = y + dy/2;
        if(!b[my][mx]) return true;
      }
      if((adx===2 && ady===1) || (adx===1 && ady===2)){
        const lx = x + (adx===2 ? (dx>0?1:-1) : 0);
        const ly = y + (ady===2 ? (dy>0?1:-1) : 0);
        if(!b[ly][lx]) return true;
      }
      if((adx===0 || ady===0 || adx===ady) && !(adx===0 && ady===0)){
        const cnt = countBetweenWithDiag(b, x,y, tx,ty);
        if(cnt===1) return true;
      }
      return false;
    }

    // ===== Movement rules =====
    function genPseudo(b,x,y){
      const p=b[y][x]; if(!p) return [];
      const out=[];
      const push=(tx,ty,extra)=>{ 
        if(!inside(tx,ty)) return; 
        const q=b[ty][tx];
        // Special case for ghost king capturing Biao
        if (p.t === 'K' && state.isGhost[p.c] && q && q.c === p.c && q.t === 'B') {
          out.push({x:tx,y:ty,cap:true, capType:q.t, ...extra});
          return;
        }
        if(q&&q.c===p.c) return; 
        out.push({x:tx,y:ty,cap:!!q, capType:q?.t||null, ...extra}); 
      };

      const isSkillMode = state.gameMode==='skill';
      const myClass = state.skill[p?.c||'r']?.classKey;
      
      if (state.chancellorActive[p.c] && p.t !== 'B') {
          const steps = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
          for (const [dx, dy] of steps) {
              push(x + dx, y + dy, { fromChancellor: true });
          }
      }

      switch(p.t){
        case 'K': {
          const steps=[[1,0],[-1,0],[0,1],[0,-1]];
          const canLeave = (isSkillMode && myClass==='K') || (isSkillMode && myClass==='B');
          for(const [dx,dy] of steps){
            const tx=x+dx, ty=y+dy;
            if(canLeave){
              if(inside(tx,ty)) push(tx,ty,{});
            }else{
              if(inside(tx,ty) && palace(tx,ty,p.c)) push(tx,ty,{});
            }
          }
          break;
        }
        case 'A': {
          const steps=[[1,1],[1,-1],[-1,1],[-1,-1]];
          for(const [dx,dy] of steps){
            const tx=x+dx, ty=y+dy;
            const canLeave = state.advisorCanLeavePalace[p.c];
            if(inside(tx,ty) && (canLeave || palace(tx,ty,p.c))) push(tx,ty,{});
          }
          break;
        }
        case 'E':
        case 'X': { //丞
          for(const [dx,dy] of [[2,2],[2,-2],[-2,2],[-2,-2]]){
            const tx=x+dx,ty=y+dy; if(!inside(tx,ty)) continue;
            if(onOwnSide(ty,p.c)!==onOwnSide(y,p.c)) continue;
            const mx=x+dx/2,my=y+dy/2; if(b[my][mx]) continue;
            push(tx,ty,{});
          } break;
        }
        case 'H': {
          for(const [dx,dy] of [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]){
            const tx=x+dx,ty=y+dy; if(!inside(tx,ty)) continue;
            const lx=x+Math.sign(dx)*(Math.abs(dx)===2?1:0), ly=y+Math.sign(dy)*(Math.abs(dy)===2?1:0);
            if(b[ly][lx]) continue; push(tx,ty,{});
          } break;
        }
        case 'R': {
          for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
            let tx=x+dx, ty=y+dy;
            while(inside(tx,ty)){
              if(!b[ty][tx]) push(tx,ty,{}); else { if(b[ty][tx].c!==p.c) push(tx,ty,{}); break; }
              tx+=dx; ty+=dy;
            }
          } break;
        }
        case 'C': {
          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
          if(isSkillMode && myClass==='C') {
            dirs.push([1,1], [1,-1], [-1,1], [-1,-1]);
          }
          for(const [dx,dy] of dirs){
            let tx=x+dx, ty=y+dy;
            const isDiag = dx!==0 && dy!==0;
            while(inside(tx,ty) && !b[ty][tx]){ 
              if(!isDiag) push(tx,ty,{}); 
              tx+=dx; ty+=dy; 
            }
            if(!inside(tx,ty)) continue;
            tx+=dx; ty+=dy;
            while(inside(tx,ty)){
              if(b[ty][tx]){ if(b[ty][tx].c!==p.c) push(tx,ty,{}); break; }
              tx+=dx; ty+=dy;
            }
          } break;
        }
        case 'S': {
          if(isSkillMode && myClass==='S'){
            for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]) push(x+dx,y+dy,{});
          }else{
            if(p.c==='r'){ if(inside(x,y-1)) push(x,y-1,{}); if(y<=4){ if(inside(x-1,y)) push(x-1,y,{}); if(inside(x+1,y)) push(x+1,y,{}); } }
            else { if(inside(x,y+1)) push(x,y+1,{}); if(y>=5){ if(inside(x-1,y)) push(x-1,y,{}); if(inside(x+1,y)) push(x+1,y,{}); } }
          }
          break;
        }
        case 'M': {
          for(const [dx,dy] of [[1,1],[1,-1],[-1,1],[-1,-1]]){
            const tx=x+dx, ty=y+dy; if(!inside(tx,ty)) continue;
            const q=b[ty][tx]; if(q&&q.c===p.c) continue; push(tx,ty,{});
          }
          for(const [dx,dy] of [[2,2],[2,-2],[-2,2],[-2,-2]]){
            const tx=x+dx, ty=y+dy; if(!inside(tx,ty)) continue;
            const mx=x+dx/2, my=y+dy/2; if(b[my][mx]) continue;
            const q=b[ty][tx]; if(q&&q.c===p.c) continue; push(tx,ty,{});
          }
          break;
        }
        case 'W': {
          const cand = [];
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=> cand.push({x:x+dx,y:y+dy,type:'step'}));
          [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dx,dy])=> cand.push({x:x+dx,y:y+dy,type:'diag1'}));
          [[2,2],[2,-2],[-2,2],[-2,-2]].forEach(([dx,dy])=> cand.push({x:x+dx,y:y+dy,type:'ele'}));
          [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dx,dy])=> cand.push({x:x+dx,y:y+dy,type:'knight'}));
          for(const c of cand){
            if(!inside(c.x,c.y)) continue;
            if(c.type==='ele'){
              const mx = x + (c.x-x)/2, my = y + (c.y-y)/2;
              if(b[my][mx]) continue;
            }
            if(c.type==='knight'){
              const adx=Math.abs(c.x-x), ady=Math.abs(c.y-y);
              const lx = x + (adx===2 ? (c.x>x?1:-1) : 0);
              const ly = y + (ady===2 ? (c.y>y?1:-1) : 0);
              if(b[ly][lx]) continue;
            }
            const q = b[c.y][c.x];
            if(q && q.c===p.c) continue;
            push(c.x,c.y,{kingCannon:false});
          }
          const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
          for(const [dx,dy] of dirs){
            let tx=x+dx, ty=y+dy;
            while(inside(tx,ty) && !b[ty][tx]){ tx+=dx; ty+=dy; }
            if(!inside(tx,ty)) continue;
            tx+=dx; ty+=dy;
            while(inside(tx,ty)){
              const q=b[ty][tx];
              if(q){
                if(q.c!==p.c) push(tx,ty,{kingCannon:true});
                break;
              }
              tx+=dx; ty+=dy;
            }
          }
          break;
        }
        case 'U': { // 君
            const dirs = [[1,1], [1,-1], [-1,1], [-1,-1]];
            for (const [dx, dy] of dirs) {
                for (let i = 1; i <= 3; i++) {
                    const tx = x + dx * i;
                    const ty = y + dy * i;
                    if (!inside(tx, ty)) break;
                    
                    let blocked = false;
                    for (let j = 1; j < i; j++) {
                        if (b[y + dy * j][x + dx * j]) {
                            blocked = true;
                            break;
                        }
                    }
                    if (blocked) break;

                    push(tx, ty, {});
                    if (b[ty][tx]) break;
                }
            }
            break;
        }
        case 'B': break; // 鏢/鑣 cannot move
      }
      return out;
    }

    function applyMove(b,fx,fy,tx,ty){ const nb=deepClone(b); nb[ty][tx]={...nb[fy][fx], id: nb[fy][fx].id}; nb[fy][fx]=null; return nb; }

    function legalMoves(b,x,y){
      const p=b[y][x]; if(!p) return [];
      let ms=genPseudo(b,x,y);
      const out=[];
      const isSkillMode = state.gameMode==='skill';
      const myClass = state.skill[p.c]?.classKey;

      if (state.palaceRestrictionFor === p.c && p.t !== 'K' && p.t !== 'A') {
          ms = ms.filter(m => !anyPalace(m.x, m.y));
      }
      if (state.forceKingMoveFor === p.c && p.t !== 'K') {
          return [];
      }
      if (state.isGhost[p.c] && p.t === 'K') {
        return ms; // Ghost king doesn't care about checks, already filtered in genPseudo
      }

      for(const m of ms){
        const targetPiece = b[m.y][m.x];
        if (m.cap && targetPiece && targetPiece.t === 'K' && state.isGhost[targetPiece.c]) {
            continue; // Cannot capture a ghost king
        }
        if (m.cap && targetPiece && targetPiece.t === 'B') {
            // Biao can ONLY be captured by its own side's Ghost King.
            const isMyGhostKing = p.t === 'K' && state.isGhost[p.c] && targetPiece.c === p.c;
            if (!isMyGhostKing) {
                continue;
            }
        }
        if (m.cap && m.capType === 'A' && p.t === 'U') {
            if (targetPiece && state.skill[targetPiece.c]?.classKey === 'A') {
                continue;
            }
        }
        if (m.cap && m.capType === 'K') {
            if (isSkillMode) {
                if (targetPiece && state.skill[targetPiece.c]?.classKey === 'K' && state.skill[p.c]?.classKey !== 'E') {
                    continue; 
                }
            }
        }
        if(p.t==='W' && m.kingCannon && !b[m.y][m.x]) continue;

        const nb=applyMove(b,x,y,m.x,m.y);

        if(generalsFace(nb)) continue;

        const ignoreCheck = (isSkillMode && myClass==='K') || (isSkillMode && myClass ==='B');
        if(!ignoreCheck && inCheck(nb,p.c)) continue;

        out.push(m);
      }
      return out;
    }

    function anyLegalMoves(b,c){ for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){ const p=b[y][x]; if(!p||p.c!==c) continue; if(legalMoves(b,x,y).length>0) return true; } return false; }

    function listAllLegalMoves(b,c){
      const list=[]; for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){
        const p=b[y][x]; if(!p||p.c!==c) continue;
        for(const m of legalMoves(b,x,y)){
          const cap=b[m.y][m.x];
          list.push({fx:x,fy:y,tx:m.x,ty:m.y,cap:!!cap,capType:cap?.t||null, id:p.id, pt:p.t});
        }
      }
      return list;
    }

    // ===== Rendering =====
    function drawGrid(){
      gridEl.innerHTML = ''; marksEl.innerHTML = ''; hlEl.innerHTML = ''; piecesEl.innerHTML = ''; overlayEl.innerHTML = '';
      gridEl.appendChild(rect(0, CELL*4+1, CELL*BOARD_WIDTH, CELL*2-2, {class:'river'}));
      gridEl.appendChild(line(0,0, CELL*(BOARD_WIDTH-1),0));
      gridEl.appendChild(line(0,CELL*(BOARD_HEIGHT-1), CELL*(BOARD_WIDTH-1), CELL*(BOARD_HEIGHT-1)));
      for(let r=0;r<BOARD_HEIGHT;r++) gridEl.appendChild(line(0, CELL*r, CELL*(BOARD_WIDTH-1), CELL*r));
      for(let f=0; f<BOARD_WIDTH; f++){ gridEl.appendChild(line(CELL*f, 0, CELL*f, CELL*4)); gridEl.appendChild(line(CELL*f, CELL*5, CELL*f, CELL*(BOARD_HEIGHT-1))); }
      marksEl.appendChild(palaceLine(3,0,5,2)); marksEl.appendChild(palaceLine(5,0,3,2)); marksEl.appendChild(palaceLine(3,9,5,7)); marksEl.appendChild(palaceLine(5,9,3,7));
      for(const [x,y] of [[1,2],[7,2],[0,3],[2,3],[4,3],[6,3],[8,3],[1,7],[7,7],[0,6],[2,6],[4,6],[6,6],[8,6]]) marksEl.appendChild(circle(cx(x), cy(y), 4, {fill:'#555'}));
      const t1=document.createElementNS('http://www.w3.org/2000/svg','text'); t1.setAttribute('x', CELL*2.0); t1.setAttribute('y', CELL*4.9); t1.setAttribute('text-anchor','middle'); t1.setAttribute('font-size','60'); t1.setAttribute('font-weight','800'); t1.setAttribute('fill','#9a8d78'); t1.textContent='楚河';
      const t2=document.createElementNS('http://www.w3.org/2000/svg','text'); t2.setAttribute('x', CELL*7.0); t2.setAttribute('y', CELL*4.9); t2.setAttribute('text-anchor','middle'); t2.setAttribute('font-size','60'); t2.setAttribute('font-weight','800'); t2.setAttribute('fill','#9a8d78'); t2.textContent='漢界';
      marksEl.appendChild(t1); marksEl.appendChild(t2);
      drawCoords();
    }
    function drawCoords(){
      const old=boardEl.querySelector('.coords'); if(old) old.remove();
      if(!state.showCoords) return;
      const g=group({class:'coords'}); const labels=['a','b','c','d','e','f','g','h','i'];
      for(let x=0;x<BOARD_WIDTH;x++){ g.appendChild(svgText(CELL*x + CELL/2, -8, labels[x], {'text-anchor':'middle'})); g.appendChild(svgText(CELL*x + CELL/2, CELL*BOARD_HEIGHT+18, labels[x], {'text-anchor':'middle'})); }
      for(let y=0;y<BOARD_HEIGHT;y++){ const ty=CELL*y + CELL/2 + 5; g.appendChild(svgText(-10, ty, String(BOARD_HEIGHT-y), {'text-anchor':'end'})); g.appendChild(svgText(CELL*BOARD_WIDTH+10, ty, String(BOARD_HEIGHT-y), {'text-anchor':'start'})); }
      boardEl.appendChild(g);
    }

    function redraw(){
      hlEl.innerHTML=''; overlayEl.innerHTML=''; piecesEl.innerHTML='';

      if(state.lastStart){
        const cls = state.lastStart.c==='r' ? 'startFillRed' : 'startFillBlack';
        hlEl.appendChild(rectCell(state.lastStart.x, state.lastStart.y, {class: cls}));
      }
      if(state.lastEnd){
        hlEl.appendChild(rectCell(state.lastEnd.x, state.lastEnd.y, {class:'endStroke'}));
      }
      
      state.grass.forEach(trapInfo => {
        if(trapInfo.traps){
          for(const g of trapInfo.traps){
            hlEl.appendChild(rectCell(g.x, g.y, {class:'vanishMark'}));
          }
        }
      });
      
      state.poisonMistInfo.forEach(mistInfo => {
        const mistClass = mistInfo.owner === 'r' ? 'mist-r' : 'mist-b';
        for(const m of mistInfo.traps){
          hlEl.appendChild(rectCell(m.x, m.y, {class: `poisonMist ${mistClass}`}));
        }
      });

      const showCheck = shouldShowCheckFor(state.turn);
      const kpos=findGeneral(state.board, state.turn);
      if(showCheck && kpos && inCheck(state.board, state.turn)){
        hlEl.appendChild(rectCell(kpos.x,kpos.y,{class:'incheck'}));
      }

      if(state.selected){
        const {x,y}=state.selected;
        hlEl.appendChild(rectCell(x,y,{class:'sel'}));
        for(const m of state.legal){
          const cls = state.turn==='r' ? 'hint-red' : 'hint-black';
          hlEl.appendChild(circle(cx(m.x), cy(m.y), 12, {class: cls + (m.cap?' hint-cap':''), r:12}));
        }
      }

      for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){
        const p=state.board[y][x]; if(!p) continue; drawPiece(x,y,p);
      }

      updateStatus();
      renderMoveList();
      renderSkillBar();
    }

    function shouldShowCheckFor(side){
      if(state.gameMode==='basic' || state.skill[side]?.classKey === 'B') return false;
      const isOpponentElephantClass = state.skill[opposite(side)]?.classKey === 'E';
      if (isOpponentElephantClass) return true;
      return state.skill[side]?.classKey!=='K';
    }

    function drawPiece(x,y,p){
      const g=group({class:'piece '+(p.c==='r'?'red':'black')});
      if (state.isGhost[p.c] && p.t === 'K') g.classList.add('ghost');

      if(state.gameMode === 'skill'){
        const skillSide = state.skill[p.c];
        if(skillSide && skillSide.classKey === p.t){
          g.classList.add('skill-' + p.t);
        } else if (skillSide && skillSide.classKey === 'B' && p.t === 'B') {
          g.classList.add('skill-B');
        }
      }
      const [dx,dy]=orient(x,y);
      const circ = circle(cx(dx), cy(dy), 36, {fill:'url(#gPiece)'});
      g.appendChild(circ);
      g.appendChild(tcenter(cx(dx), cy(dy), pieceChar[p.c][p.t]));
      g.addEventListener('pointerdown', (e)=>{ e.preventDefault(); onSquareClick(x,y); });
      piecesEl.appendChild(g);
    }

    function updateStatus(){
      turnBadge.textContent = '輪到：' + (state.turn==='r'?'紅方':'黑方');
      turnBadge.className = 'turn ' + (state.turn==='r'?'red':'black');

      const showCheck = shouldShowCheckFor(state.turn);
      if(showCheck && inCheck(state.board, state.turn)){
        statusMsg.textContent = '將軍！';
        statusMsg.className = 'msg check';
      }else{
        if(!state.over){ statusMsg.textContent=''; statusMsg.className='msg'; }
      }

      const s = state.skill[state.turn];
      if(state.gameMode==='skill' && s.phase==='A'){
        actionBadge.style.display = 'inline-block';
        if(s.classKey==='S') actionBadge.textContent = `A技：三步登天（剩 ${s.aStepsLeft}/3）`;
        else if(s.classKey==='K') actionBadge.textContent = 'A技：草叢陷阱（已標記）';
        else if(s.classKey==='C') actionBadge.textContent = 'A技：驚不驚喜（已發動）';
      }else if(state.gameMode==='skill' && s.phase==='B'){
        actionBadge.style.display = 'inline-block';
        if(s.classKey==='S') actionBadge.textContent = `B技：指敵為友（選目標）`;
        else if(s.classKey==='K') actionBadge.textContent = `B技：替身司令（選擇一枚敵子）`;
        else if(s.classKey==='C') actionBadge.textContent = 'B技：意不意外（選擇目標）';
      }else{
        actionBadge.style.display = 'none';
      }
    }

    function renderSkillBar(){
      if(state.gameMode!=='skill'){
        skillBar.style.display='none';
        legendEl.classList.remove('skill');
        return;
      }
      skillBar.style.display='flex';
      legendEl.classList.add('skill');

      const sc = state.skill[state.turn];
      const cls = Object.keys(CLASS_KEY).find(k=>CLASS_KEY[k]===sc.classKey) || '無';
      skillTag.textContent = '類別：' + cls;

      if(sc.classKey==='S'){
        btnA.textContent = 'A技：三步登天';
        btnB.textContent = 'B技：指敵為友';
        btnUltra.textContent = '必殺技：進化成王';
      } else if (sc.classKey==='K'){
        btnA.textContent = 'A技：草叢陷阱';
        btnB.textContent = 'B技：替身司令';
        btnUltra.textContent = '必殺技：臣下凡仙';
      } else if (sc.classKey==='C'){
        btnA.textContent = 'A技：驚不驚喜';
        btnB.textContent = 'B技：意不意外';
        btnUltra.textContent = '必殺技：槍砲有眼';
      } else if (sc.classKey==='E'){
        btnA.textContent = 'A技：事功半倍';
        btnB.textContent = 'B技：功半事倍';
        btnUltra.textContent = '必殺技：丞臨天下';
      } else if (sc.classKey==='A'){
        btnA.textContent = 'A技：井底之土';
        btnB.textContent = 'B技：聽天仕命';
        btnUltra.textContent = '必殺技：君辱神亡';
      } else if (sc.classKey === 'B') {
        btnA.textContent = 'A技：智取滅亡';
        btnB.textContent = 'B技：棄車保卒';
        btnUltra.textContent = '必殺技：無法無天';
      }

      const isAIturn = (state.playMode==='ai' && state.turn===state.aiSide);
      const lock = state.skill[state.turn].skillLockForThisTurn;

      let prog=0, unlockA=false, unlockB=false;
      if(sc.classKey==='K') { prog=sc.progK; unlockA=sc.unlockAK; unlockB=sc.unlockBK; }
      else if(sc.classKey==='S') { prog=sc.progS; unlockA=sc.unlockAS; unlockB=sc.unlockBS; }
      else if(sc.classKey==='C') { prog=sc.progC; unlockA=sc.unlockAC; unlockB=sc.unlockBC; }
      else if(sc.classKey==='E') { prog=sc.progE; unlockA=sc.unlockAE; unlockB=sc.unlockBE; }
      else if(sc.classKey==='A') { prog=sc.progA; unlockA=sc.unlockAA; unlockB=sc.unlockBA; }
      else if(sc.classKey==='B') { prog=sc.progB; unlockA=sc.unlockAB; unlockB=sc.unlockBB; }
      
      let progMax = sc.progMax;

      // [BUG FIX] Always render the main progress bar (絕招進度)
      const pct = Math.min(100, (prog/progMax)*100);
      progBar.style.width = pct + '%';
      progMeta.textContent = sc.classKey === 'B' ? `${pct}%（${prog}/${progMax} 跳過）` : `${pct}%（${prog}/${progMax}）`;
      
      if(sc.classKey === 'E'){
          let charge = 0;
          if(sc.usedA) charge += 50;
          if(sc.usedB) charge += 50;
          ultraBar.style.width = charge + '%';
          ultraMeta.textContent = `${charge}%`;
      } else {
        ultraBar.style.width = sc.ultraUnlocked ? '100%' : '0%';
        ultraMeta.textContent = sc.ultraUnlocked ? (sc.ultraUsed ? '已使用' : '可用') : '未解鎖';
      }


      const anySkillActive = sc.phase!=='normal' || sc.skillLockForThisTurn;

      const hasClassPiece = allPieceIds(state.turn, sc.classKey).length > 0 || sc.classKey === 'B';

      let canA = !isAIturn && unlockA && !sc.usedA && sc.phase==='normal' && hasClassPiece && !lock;
      let canB = !isAIturn && unlockB && !sc.usedB && sc.phase==='normal' && !lock;
      let canU = !isAIturn && sc.ultraUnlocked && !sc.ultraUsed && sc.phase==='normal' && !lock;
      
      if(sc.classKey==='S') {
        if(!allPieceIds(state.turn,'S').length > 0) canA = false;
      }

      const showA = !sc.usedA && (!anySkillActive || (sc.phase==='A'));
      const showB = !sc.usedB && (!anySkillActive || (sc.phase==='B'));
      let showU = !sc.ultraUsed && (!anySkillActive);
      
      const oppoSc = state.skill[opposite(state.turn)];
      if (oppoSc.classKey === 'B' && oppoSc.ultraStealState === 'disable') {
        showU = false;
      }


      btnA.style.display = showA ? 'inline-block' : 'none';
      btnB.style.display = showB ? 'inline-block' : 'none';
      btnUltra.style.display = showU ? 'inline-block' : 'none';

      btnA.disabled = !canA;
      btnB.disabled = !canB;
      btnUltra.disabled = !canU;
    }

    function renderMoveList(){}

    // ===== Interaction =====
    boardEl.addEventListener('pointerdown', onBoardPointer);
    function onBoardPointer(e){
      if(state.over) return;
      if(state.playMode==='ai' && state.turn===state.aiSide) return;
      if(state.gameMode==='guide') return;
      const pt = boardPoint(e);
      const file = Math.floor(pt.x / CELL);
      const rank = Math.floor(pt.y / CELL);
      if(file<0||file>=BOARD_WIDTH||rank<0||rank>=BOARD_HEIGHT) return;
      const [bx,by] = deorient(file,rank);
      onSquareClick(bx,by);
    }

    function onSquareClick(x,y){
      if(state.over) return;
      if(state.playMode==='ai' && state.turn===state.aiSide) return;

      const p = state.board[y][x];
      const side = state.turn;
      const sc = state.skill[side];

      if(state.gameMode==='skill'){
        if(sc.phase === 'A'){
          if(sc.classKey==='S'){
            if(sc.aLock){
              if(state.selected){
                const mv = state.legal.find(m => m.x===x && m.y===y);
                if(mv){ executeMove(state.selected.x, state.selected.y, x,y, {fromSkill:'A'}); return; }
              }else{
                if(p && p.c===side && p.id===sc.aLock){
                  state.selected = {x,y};
                  state.legal = legalMoves(state.board,x,y);
                  redraw();
                }
              }
            }else{
              if(p && p.c===side && p.t==='S'){
                state.selected = {x,y};
                state.legal = legalMoves(state.board,x,y);
                sc.aLock = p.id;
                sc.aStepsLeft = 3;
                redraw();
              }else{ showToast('請先選擇一枚你的兵/卒'); }
            }
            return;
          }
        } else if (sc.phase === 'B') {
          if(sc.classKey==='S'){
            if(p && p.c===opposite(side) && p.t!=='K' && p.t!=='A' && p.t!=='W' && p.t !== 'B'){
              sc.bTarget = {x,y};
              performS_B(side);
              endTurn();
            }else{ showToast('請點擊可轉化的敵子（不可為將/帥、士/仕、王、鏢/鑣）'); }
          } else if(sc.classKey==='K'){
            if(p && p.c===opposite(side) && p.t!=='K' && p.t!=='W'){
                performK_B(side, {x,y});
                endTurn();
            } else { showToast('請選擇一枚敵子（不得為將/帥或王）'); }
          } else if(sc.classKey==='C'){
            if(p && p.c===opposite(side) && p.t !== 'K' && p.t !== 'W'){
                performC_B(side, {x,y});
                endTurn();
            } else { showToast('請選擇一枚敵子作為中心點（不得為將/帥或王）'); }
          }
          return;
        }
      }

      // 正常點擊
      if(state.selected){
        const mv = state.legal.find(m => m.x===x && m.y===y);
        if(mv){ executeMove(state.selected.x, state.selected.y, x,y); return; }
      }
      if(p && p.c === side){
        state.selected = {x,y};
        state.legal = legalMoves(state.board,x,y);
      }else{
        state.selected = null;
        state.legal = [];
      }
      redraw();
    }

    // ===== Execute move & rules =====
    function executeMove(fx,fy,tx,ty, opts={}){
      const movingPiece = { ...state.board[fy][fx] };
      const target = state.board[ty][tx] ? { ...state.board[ty][tx] } : null;

      if(state.gameMode==='basic') pushHistory();
      
      if (state.gameMode === 'skill' && target && target.t === 'K') {
          const targetSkillClass = state.skill[target.c]?.classKey;
          if (targetSkillClass === 'K' && state.skill[movingPiece.c]?.classKey !== 'E') {
              showToast('將/帥不死，不能被吃');
              return;
          }
      }
      
      // *** BUG FIX START: Stricter rules for Ghost King captures ***
      if (movingPiece.t === 'K' && state.isGhost[movingPiece.c] && target) {
          if (target.t === 'B') {
              if (target.c === movingPiece.c) {
                  // Correct: Own Ghost King captures own Biao
                  performBiao_Capture(movingPiece.c);
                  return; 
              } else {
                  // Incorrect: Trying to capture enemy Biao. This move should be illegal, but this is a safeguard.
                  showToast('幽靈帥不能吃敵方的鏢/鑣。');
                  return;
              }
          } else {
              // Ghost King tries to capture a non-Biao piece
              showToast('幽靈帥只能吃己方鏢，不能吃其他棋子。');
              return;
          }
      }
      // *** BUG FIX END ***

      state.lastStart = {x:fx,y:fy, c: movingPiece.c};
      state.lastEnd = {x:tx,y:ty};

      state.board = applyMove(state.board, fx,fy, tx,ty);
      state.lastMove = {fx,fy,tx,ty};
      logMove(fx,fy,tx,ty, movingPiece);

      if (state.gameMode !== 'skill' || state.skill[target?.c]?.classKey !== 'B') {
        if (target && target.t === 'K') {
            endGameByForce(movingPiece.c, '吃掉將/帥');
            redraw();
            return; 
        }
      }
      
      if (target && target.t === 'X') {
          const victimSide = target.c;
          if (allPieceIds(victimSide, 'X').length === 0) {
              state.chancellorActive[victimSide] = false;
              showToast(`${victimSide === 'r' ? '紅方' : '黑方'}的「丞」已被全滅，丞相效果消失！`);
          }
      }

      if(target && target.t==='S'){
        const victim = target.c;
        const killer = movingPiece;
        state.skill[victim].lastPawnDeath = { at:{x:tx,y:ty}, killerType:killer.t, killedByKing:(killer.t==='K') };
        state.pawnLossCount[victim] = (state.pawnLossCount[victim]||0)+1;
        checkUltraUnlock_S(victim);
      }

      if(state.gameMode==='skill'){
        const sc = state.skill[state.turn];
        if(movingPiece.t==='S' && opts.fromSkill!=='A'){
          sc.progS = Math.min(sc.progMax, sc.progS + 1); if(sc.progS>=sc.progMax){ sc.unlockAS=true; sc.unlockBS=true; }
        } else if(movingPiece.t==='K'){
          sc.progK = Math.min(sc.progMax, sc.progK + 1); if(sc.progK>=sc.progMax){ sc.unlockAK=true; sc.unlockBK=true; }
        } else if(movingPiece.t==='C'){
          sc.progC = Math.min(sc.progMax, sc.progC + 1); if(sc.progC>=sc.progMax){ sc.unlockAC=true; sc.unlockBC=true; }
        } else if(movingPiece.t==='E' || movingPiece.t ==='X'){
          sc.progE = Math.min(sc.progMax, sc.progE + 1); if(sc.progE>=sc.progMax){ sc.unlockAE=true; sc.unlockBE=true; }
        } else if (movingPiece.t === 'A') {
            sc.progA = Math.min(sc.progMax, sc.progA + 1); if (sc.progA >= sc.progMax) { sc.unlockAA = true; sc.unlockBA = true; }
            const oppoSc = state.skill[opposite(state.turn)];
            if (oppoSc.classKey === 'A') {
                oppoSc.ultraUnlocked = true;
                showToast('敵方解鎖必殺技：君辱神亡！');
            }
        }
      }

      if(state.gameMode==='skill'){
        const sc = state.skill[state.turn];
        if(sc.classKey==='S' && sc.phase==='A'){
          if(target){ endTurn(); redraw(); return; }
          sc.aStepsLeft = Math.max(0, sc.aStepsLeft - 1);
          if(sc.aStepsLeft===0 || opts.forceEnd){ endTurn(); redraw(); return; }
          state.selected = null; state.legal=[]; redraw(); return;
        }
      }
      
      const movedPiece = state.board[ty][tx];
      if(movedPiece){
        state.poisonMistInfo.forEach(mistInfo => {
           if (movedPiece.c !== mistInfo.owner) {
              if (mistInfo.traps.some(trap => trap.x === tx && trap.y === ty)) {
                  state.board[ty][tx] = null;
                  showToast('敵棋進入毒霧，消失了！');
              }
           }
        });
      }


      if(opts.forceEnd){ endTurn(); redraw(); return; }

      endTurn();
      redraw();
    }

    function endGameByForce(winnerColor, reason){
      state.over = true;
      statusMsg.textContent = (winnerColor==='r'?'紅方':'黑方') + '勝！' + (reason?('（'+reason+'）'):'');
      statusMsg.className = 'msg mate';
      cancelAiTimeout();
      state.aiBusy=false;
    }

    function endTurn(){
      state.turnCount++;
      resolveGrassTrapsAtTurnEnd();
      
      const sideThatJustFinished = state.turn;
      const sc = state.skill[sideThatJustFinished];

      if(state.tempCannonTransforms.length > 0 && !(sc.classKey === 'C' && sc.usedA && !state.over)){
        state.tempCannonTransforms.forEach(t => {
            const p = findPieceById(t.id);
            if(p) state.board[p.y][p.x].t = t.originalType;
        });
        state.tempCannonTransforms = [];
      }

      if(sc.phase==='A'){ sc.phase='normal'; sc.aLock=null; sc.aStepsLeft=0; sc.usedA=true; }
      else if(sc.phase==='B'){ sc.phase='normal'; sc.bTarget=null; sc.usedB=true; }
      sc.skillLockForThisTurn = false;
      
      spawnNewMist();

      state.selected=null; state.legal=[];
      const nextTurn = opposite(state.turn);

      // If the player who just moved was under the king-move restriction, clear the flag.
      if (state.forceKingMoveFor === sideThatJustFinished) {
          state.forceKingMoveFor = null;
      }

      state.turn = nextTurn;

      if (state.skill[state.turn].classKey === 'B' && state.turn !== state.aiSide) {
        skipBtn.style.display = 'inline-block';
      } else {
        skipBtn.style.display = 'none';
      }

      if (state.forceKingMoveFor === state.turn) {
          if (!anyLegalMoves(state.board, state.turn)) {
              endGameByForce(opposite(state.turn), '將/帥無路可走');
              redraw();
              return;
          }
      }

      refreshAllUltraUnlock();
      evaluateEndState();
      
      tryTriggerAI();
    }

    function evaluateEndState(){
      if(state.over) return;
      
      const biaoR = state.skill.r.classKey === 'B';
      const biaoB = state.skill.b.classKey === 'B';

      if (biaoR || biaoB) {
          const countPieces = (side) => {
              if (state.isGhost[side]) return 11; // Special value, not losing
              let count = 0;
              for (let y = 0; y < BOARD_HEIGHT; y++) {
                  for (let x = 0; x < BOARD_WIDTH; x++) {
                      if (state.board[y][x] && state.board[y][x].c === side) {
                          count++;
                      }
                  }
              }
              return count;
          };

          if (biaoR) {
              const rCount = countPieces('r');
              if (rCount <= 10) {
                  endGameByForce('b', '紅方棋子數不足而戰敗');
                  return;
              }
          }
          if (biaoB) {
              const bCount = countPieces('b');
              if (bCount <= 10) {
                  endGameByForce('r', '黑方棋子數不足而戰敗');
                  return;
              }
          }
          return; // Biao victory condition is exclusive
      }
      
      // Original end game logic
      if (!findGeneral(state.board, 'r')) {
          endGameByForce('b', '帥已被吃');
          return;
      }
      if (!findGeneral(state.board, 'b')) {
          endGameByForce('r', '將已被吃');
          return;
      }

      if(state.gameMode==='basic'){
        const defender = state.turn;
        const check = inCheck(state.board, defender);
        const hasMoves = anyLegalMoves(state.board, defender);
        if(!hasMoves){
          state.over = true;
          statusMsg.textContent = check ? ((defender==='r'?'紅方':'黑方')+'被將死！') : '僵局（無合法步）';
          statusMsg.className = 'msg ' + (check?'mate':'draw');
          cancelAiTimeout();
          state.aiBusy=false;
          return;
        }
        statusMsg.textContent = check ? '將軍！' : '';
        statusMsg.className = 'msg ' + (check?'check':'');
        return;
      }

      const countPieces = (side)=>{
        let cnt=0; for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){ const p=state.board[y][x]; if(p && p.c===side) cnt++; } return cnt;
      };
      const rCnt = countPieces('r'), bCnt = countPieces('b');
      const rOnlyK = (rCnt===1 && findGeneral(state.board, 'r'));
      const bOnlyK = (bCnt===1 && findGeneral(state.board, 'b'));

      if(rOnlyK && bOnlyK){
        state.over = true;
        statusMsg.textContent = '雙方皆僅剩將/帥，和局';
        statusMsg.className = 'msg draw';
        cancelAiTimeout(); state.aiBusy=false; return;
      }
      if(rOnlyK){ endGameByForce('b', '紅方僅剩帥'); return; }
      if(bOnlyK){ endGameByForce('r', '黑方僅剩將'); return; }
    }

    // ===== 草叢陷阱（K-A）=====
    function performK_A(side){
      const enemy = opposite(side);
      const enemyList=[];
      for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){
        const p=state.board[y][x]; 
        if(p && p.c===enemy && p.t !== 'K') enemyList.push({x,y,id:p.id});
      }
      shuffle(enemyList);
      const pick = enemyList.slice(0, Math.min(3, enemyList.length));
      
      const traps = [];
      for(const pk of pick){
        traps.push({sid: pk.id, x: pk.x, y: pk.y});
      }
      state.grass.push({ owner: side, traps: traps }); 
      
      showToast(`草叢陷阱：標記 ${pick.length} 枚敵子`);
      const sc = state.skill[side];
      sc.phase='A';
      sc.skillLockForThisTurn = true;
      redraw();
    }

    function resolveGrassTrapsAtTurnEnd(){
      const trapToResolve = state.grass.find(t => t.owner === opposite(state.turn));
      if (!trapToResolve) return;
      
      let vanishedCount = 0;
      for(const g of trapToResolve.traps){
        const pos = findPieceById(g.sid);
        if(pos && pos.x === g.x && pos.y === g.y){
          state.board[g.y][g.x] = null;
          vanishedCount++;
        }
      }
      
      if(vanishedCount > 0){
        showToast(`草叢陷阱：${vanishedCount} 枚敵棋消失！`);
      }
      
      state.grass = state.grass.filter(t => t.owner !== opposite(state.turn));
      redraw();
    }


    // Logic for K-B skill, "替身司令"
    function performK_B(side, targetPos){
      const kpos = findGeneral(state.board, side);
      if(!kpos) { showToast('錯誤：找不到你的將/帥'); return; }

      const kingObject = state.board[kpos.y][kpos.x];
      const targetObject = state.board[targetPos.y][targetPos.x];

      state.board[targetPos.y][targetPos.x] = kingObject;
      state.board[kpos.y][kpos.x] = null;

      state.lastStart = { x: kpos.x, y: kpos.y, c: side };
      state.lastEnd = { x: targetPos.x, y: targetPos.y };
      logMove(kpos.x, kpos.y, targetPos.x, targetPos.y, kingObject, ` (替身司令, 消滅 ${pieceChar[targetObject.c][targetObject.t]})`);
      
      const sc = state.skill[side];
      sc.usedB = true;
      sc.phase = 'normal';
      sc.skillLockForThisTurn = true;
      showToast('B技：替身司令！');
    }

    // ===== 臣下凡仙（K-大招）=====
    function performK_Ultra(side){
      const kpos = findGeneral(state.board, side);
      if(!kpos){ showToast('未找到將/帥'); return; }
      const around = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
      let created=0;
      for(const [dx,dy] of around){
        const x=kpos.x+dx, y=kpos.y+dy;
        if(!inside(x,y)) continue;
        const q = state.board[y][x];
        if(q && q.t==='K' && q.c===opposite(side)) continue;
        if(q && q.t === 'B') continue;
        state.board[y][x] = { c: side, t:'M', id: Math.random().toString(36).slice(2) };
        created++;
      }
      showToast(`必殺技：臣下凡仙！生成 ${created} 個「臣」`);
      const sc = state.skill[side];
      sc.ultraUsed = true;
      sc.skillLockForThisTurn = true;
      redraw();
    }

    // ===== S-B：指敵為友 =====
    function performS_B(side){
      const sc = state.skill[side];
      const tgt = sc.bTarget;
      if(!tgt) return;
      const q = state.board[tgt.y][tgt.x];
      if(!q || q.c!==opposite(side) || q.t==='K' || q.t==='A' || q.t==='W' || q.t === 'B') return;

      state.board[tgt.y][tgt.x] = { c: side, t:'S', id: Math.random().toString(36).slice(2) };
      sc.usedB = true; sc.phase='normal';
      sc.skillLockForThisTurn = true; sc.bTarget=null;

      showToast('指敵為友：已轉化為你的兵/卒');
      refreshAllUltraUnlock();
      redraw();
    }

    // ===== S-大招（進化成王）=====
    function doUltraRevive_S(side){
      const sc = state.skill[side];
      const info = sc.lastPawnDeath;
      if(!info){ showToast('沒有可復活的兵/卒記錄'); return; }

      let rx, ry;
      if(info.killedByKing){
        if(side==='r'){ rx=4; ry=6; } else { rx=4; ry=3; }
      }else{
        rx = info.at.x; ry = info.at.y;
      }
      state.board[ry][rx] = { c: side, t:'W', id: Math.random().toString(36).slice(2) };
      requestAnimationFrame(()=> kingAppearFX(rx, ry));

      sc.ultraUsed = true;
      sc.skillLockForThisTurn = true;

      showToast('必殺技：進化成王！王已現身');
      redraw();
    }
    
    // ===== 炮/砲技能 =====
    function performC_A(side){
        const myPieces = [];
        for(let y=0; y<BOARD_HEIGHT; y++) for(let x=0; x<BOARD_WIDTH; x++){
            const p = state.board[y][x];
            if(p && p.c === side && p.t !== 'K') myPieces.push(p);
        }
        shuffle(myPieces);
        const toTransform = myPieces.slice(0,5);
        
        state.tempCannonTransforms = [];
        toTransform.forEach(p => {
            const pos = findPieceById(p.id);
            if(pos){
                state.tempCannonTransforms.push({id: p.id, originalType: p.t});
                state.board[pos.y][pos.x].t = 'C';
            }
        });
        
        showToast(`A技：驚不驚喜！ ${toTransform.length} 枚棋子暫時變為炮！`);
        const sc = state.skill[side];
        sc.phase = 'normal'; 
        sc.usedA = true;
        sc.skillLockForThisTurn = true;
        redraw();
    }

    function performC_B(side, targetPos){
        const around = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        let vanishedCount = 0;
        
        for(const [dx,dy] of around){
            const x = targetPos.x + dx;
            const y = targetPos.y + dy;
            if(inside(x,y)){
                const p = state.board[y][x];
                if(p && p.c === opposite(side) && p.t!=='K'){ 
                    state.board[y][x] = null;
                    vanishedCount++;
                }
            }
        }
        
        const centerPiece = state.board[targetPos.y][targetPos.x];
        if(centerPiece && centerPiece.c === opposite(side) && centerPiece.t !== 'K'){
          state.board[targetPos.y][targetPos.x] = null; 
          vanishedCount++;
        }

        showToast(`B技：意不意外！ ${vanishedCount} 枚棋子消失！`);
        const sc = state.skill[side];
        sc.phase = 'normal';
        sc.usedB = true;
        sc.skillLockForThisTurn = true;
        redraw();
    }
    
    function performC_Ultra(side){
        state.poisonMistInfo.push({ owner: side, traps: [], lastSpawnTurn: state.turnCount });
        spawnNewMist(side); 
        
        showToast('必殺技：槍砲有眼！毒霧已生成！');
        const sc = state.skill[side];
        sc.ultraUsed = true;
        sc.skillLockForThisTurn = true;
        redraw();
    }
    
    function spawnNewMist(isFirstForOwner = null){
        const spawnLogic = (mistInfo) => {
            const enemy = opposite(mistInfo.owner);
            const emptySquares = [];
            const startY = enemy === 'r' ? 5 : 0;
            const endY = enemy === 'r' ? 9 : 4;
            
            const allMistLocations = new Set();
            state.poisonMistInfo.forEach(info => {
                info.traps.forEach(t => allMistLocations.add(`${t.x},${t.y}`));
            });

            for(let y = startY; y <= endY; y++){
                for(let x = 0; x < BOARD_WIDTH; x++){
                    if(!state.board[y][x] && !palace(x, y, enemy) && !allMistLocations.has(`${x},${y}`)){
                        emptySquares.push({x,y});
                    }
                }
            }

            if(emptySquares.length > 0){
                shuffle(emptySquares);
                const spot = emptySquares[0];
                mistInfo.traps.push({x: spot.x, y: spot.y});
                mistInfo.lastSpawnTurn = state.turnCount;
                
                if(!isFirstForOwner) {
                  showToast(`${mistInfo.owner === 'r' ? '紅方' : '黑方'}の新毒霧出現了！`);
                }
                redraw();
            }
        };

        if(isFirstForOwner){
            const mistInfo = state.poisonMistInfo.find(m => m.owner === isFirstForOwner);
            if(mistInfo) spawnLogic(mistInfo);
        } else {
            state.poisonMistInfo.forEach(mistInfo => {
                if ((state.turnCount - mistInfo.lastSpawnTurn) > 0 && (state.turnCount - mistInfo.lastSpawnTurn) % 4 === 0) {
                    spawnLogic(mistInfo);
                }
            });
        }
    }
    
    // ===== 象/相 技能 =====
    function performE_A(side){
      const sc = state.skill[side];
      sc.usedA = true;
      showToast('A技：事功半倍！必殺技充能50%！');
      refreshAllUltraUnlock();
      sc.skillLockForThisTurn = true;
    }
    
    function performE_B(side){
      const sc = state.skill[side];
      sc.usedB = true;
      showToast('B技：功半事倍！必殺技充能50%！');
      refreshAllUltraUnlock();
      sc.skillLockForThisTurn = true;
    }

    function performE_Ultra(side){
        for (let y=0; y<BOARD_HEIGHT; y++) {
            for (let x=0; x<BOARD_WIDTH; x++) {
                const p = state.board[y][x];
                if (p && p.c === side && p.t === 'E') {
                    state.board[y][x].t = 'X'; // 丞
                }
            }
        }
        state.chancellorActive[side] = true;
        showToast('必殺技：丞臨天下！相/象進化為丞！');
        const sc = state.skill[side];
        sc.ultraUsed = true;
        sc.skillLockForThisTurn = true;
    }

    // ===== 士/仕 技能 =====
    function performA_A(side) {
        state.advisorCanLeavePalace[side] = true;
        showToast('A技：井底之土！仕/士可離開九宮！');
        const sc = state.skill[side];
        sc.usedA = true;
        sc.skillLockForThisTurn = true;
    }

    function performA_B(side) {
        state.palaceRestrictionFor = opposite(side);
        showToast('B技：聽天仕命！敵方主力無法進入九宮！');
        const sc = state.skill[side];
        sc.usedB = true;
        sc.skillLockForThisTurn = true;
    }
    
    function performA_Ultra(side) {
        const enemySide = opposite(side);
        const enemyClass = state.skill[enemySide].classKey;
        let transformedCount = 0;
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const p = state.board[y][x];
                if (p && p.c === enemySide && p.t !== 'K' && p.t !== enemyClass) {
                    p.t = 'U'; // 君
                    transformedCount++;
                }
            }
        }
        showToast(`必殺技：君辱神亡！${transformedCount}枚敵棋變為「君」！`);
        const sc = state.skill[side];
        sc.ultraUsed = true;
        sc.skillLockForThisTurn = true;
    }

    // ===== 鏢/鑣 技能 =====
    function performBiao_A(side) {
        const enemySide = opposite(side);
        const enemyPalaceEmptySquares = [];
        const startY = enemySide === 'r' ? 7 : 0;
        const endY = startY + 2;

        for (let y = startY; y <= endY; y++) {
            for (let x = 3; x <= 5; x++) {
                if (!state.board[y][x]) {
                    enemyPalaceEmptySquares.push({x, y});
                }
            }
        }

        if (enemyPalaceEmptySquares.length === 0) {
            endGameByForce(side, '敵方九宮無處可去！');
            return;
        }

        const myKingPos = findGeneral(state.board, side);
        if (!myKingPos) return;

        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const p = state.board[y][x];
                if (p && p.c === side && p.t !== 'K' && p.t !== 'B') {
                    state.board[y][x] = null;
                }
            }
        }
        
        state.isGhost[side] = true;
        const targetSquare = shuffle(enemyPalaceEmptySquares)[0];
        state.board[myKingPos.y][myKingPos.x] = null;
        state.board[targetSquare.y][targetSquare.x] = {c: side, t: 'K', id: Math.random().toString(36).slice(2)};

        showToast('A技：智取滅亡！將/帥已幽靈化！');
        const sc = state.skill[side];
        sc.usedA = true;
        sc.skillLockForThisTurn = true;
        endTurn();
    }
    
    function performBiao_B(side) {
        state.forceKingMoveFor = opposite(side);
        showToast('B技：棄車保卒！敵方下回合只能動將/帥！');
        const sc = state.skill[side];
        sc.usedB = true;
        sc.skillLockForThisTurn = true;
        endTurn();
    }
    
    function performBiao_Ultra(side) {
        const sc = state.skill[side];
        const oppo = opposite(side);
        const oppoSc = state.skill[oppo];
        let message = "必殺技：無法無天！";

        const oppoSkillsUnlocked = oppoSc.unlockAA || oppoSc.unlockAB || oppoSc.unlockAC || oppoSc.unlockAE || oppoSc.unlockAK || oppoSc.unlockAS;

        if (oppoSc.ultraUsed) {
            // Steal
            let stolenPieces = [];
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const p = state.board[y][x];
                    if (p && p.c === oppo && ['W', 'M', 'X'].includes(p.t)) {
                        p.c = side;
                        stolenPieces.push(p.t);
                    }
                }
            }
            state.poisonMistInfo.forEach(mist => {
                if (mist.owner === oppo) mist.owner = side;
            });
            if (state.chancellorActive[oppo]) {
                state.chancellorActive[side] = true;
                state.chancellorActive[oppo] = false;
            }

            if (stolenPieces.length > 0) {
                message += `已偷取敵方 ${stolenPieces.length} 枚棋子！`;
            } else {
                message += "偷取效果發動！";
            }
             sc.ultraStealState = 'stolen';

        } else if (oppoSkillsUnlocked) {
            // Disable
            message += "已隱藏敵方必殺技！";
            sc.ultraStealState = 'disable';

        } else {
            // Increase cost
            if(oppoSc.classKey !== 'B') {
              oppoSc.progMax = 20;
              message += "敵方技能解鎖難度提升！";
            } else {
              message += "對手為鏢/鑣，難度無變化。";
            }
        }
        
        showToast(message);
        sc.ultraUsed = true;
        sc.skillLockForThisTurn = true;
        endTurn();
    }
    
    function performBiao_Capture(side) {
        state.isGhost[side] = false;
        // Find Biao and remove it
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const p = state.board[y][x];
                if (p && p.c === side && p.t === 'B') {
                    state.board[y][x] = null;
                    break;
                }
            }
        }

        const emptySquares = [];
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                if (!state.board[y][x]) {
                    emptySquares.push({x, y});
                }
            }
        }
        
        shuffle(emptySquares);
        const toSpawn = Math.min(24, emptySquares.length);
        for(let i=0; i<toSpawn; i++){
            const sq = emptySquares[i];
            state.board[sq.y][sq.x] = {c: side, t: 'K', id: Math.random().toString(36).slice(2)};
        }
        
        showToast('鏢/鑣被回收！24位將/帥援軍抵達！');
        endTurn();
    }


    function kingAppearFX(x,y){
      const [dx,dy]=orient(x,y);
      const cxv = cx(dx), cyv = cy(dy);
      const glow = circle(cxv, cyv, 46, {class:'kfx-glow'});
      const ring1 = circle(cxv, cyv, 52, {class:'kfx-ring'});
      const ring2 = circle(cxv, cyv, 68, {class:'kfx-ring kfx-ring2'});
      const star = document.createElementNS('http://www.w3.org/2000/svg','path');
      star.setAttribute('d', starPath(cxv, cyv, 14, 34, 5));
      star.setAttribute('class','kfx-star');
      overlayEl.appendChild(glow);
      overlayEl.appendChild(ring1);
      overlayEl.appendChild(ring2);
      overlayEl.appendChild(star);
      setTimeout(()=>{ [glow,ring1,ring2,star].forEach(n=> n && n.remove()); }, 1400);
    }
    function starPath(cx,cy, r1,r2, points){
      let d=''; const step=Math.PI/points;
      for(let i=0;i<points*2;i++){
        const r = (i%2===0)?r2:r1;
        const a = i*step - Math.PI/2;
        const x = cx + Math.cos(a)*r;
        const y = cy + Math.sin(a)*r;
        d += (i===0?'M':'L') + x + ' ' + y + ' ';
      }
      d += 'Z'; return d;
    }

    // ===== Ultra unlocks =====
    function checkUltraUnlock_S(side){
      const isAI = (state.playMode==='ai' && side===state.aiSide);
      const pawnsAlive = allPieceIds(side,'S').length;
      if(isAI){ if(state.pawnLossCount[side]>=1) state.skill[side].ultraUnlocked = true; }
      else { if(pawnsAlive===0) state.skill[side].ultraUnlocked = true; }
    }
    function checkUltraUnlock_K(side){
      const pieces = [];
      for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){ const p=state.board[y][x]; if(p && p.c===side) pieces.push(p); }
      if(pieces.length===2 && pieces.some(p=> p.t==='K')){
        state.skill[side].ultraUnlocked = true;
      }
    }
    function checkUltraUnlock_C(side){
        const cannonCount = allPieceIds(side, 'C').length;
        if(cannonCount === 1) state.skill[side].ultraUnlocked = true;
    }
    function checkUltraUnlock_E(side) {
        const sc = state.skill[side];
        if (sc.usedA && sc.usedB) {
            sc.ultraUnlocked = true;
        }
    }
    function refreshAllUltraUnlock(){
      ['r', 'b'].forEach(side => {
        const sc = state.skill[side];
        if (!sc.classKey) return;
        switch(sc.classKey) {
            case 'S': checkUltraUnlock_S(side); break;
            case 'K': checkUltraUnlock_K(side); break;
            case 'C': checkUltraUnlock_C(side); break;
            case 'E': checkUltraUnlock_E(side); break;
        }
      });
      renderSkillBar();
    }

    // ===== Move logging =====
    function coordName(x,y){ const files=['a','b','c','d','e','f','g','h','i']; return files[x] + (BOARD_HEIGHT - y); }
    function logMove(fx,fy,tx,ty, movingPiece, note=""){
      const idx = movelistEl.children.length + 1;
      const line = document.createElement('div'); line.className='moveline';
      const idxEl = document.createElement('div'); idxEl.className='idx'; idxEl.textContent = idx+'.';
      const mvEl = document.createElement('div'); mvEl.className='mv';
      const sideStr = (movingPiece?.c==='r'?'紅':'黑');
      const pieceSym = movingPiece ? pieceChar[movingPiece.c][movingPiece.t] : '';
      mvEl.textContent = sideStr + ' ' + pieceSym + ' ' + coordName(fx,fy) + ' → ' + coordName(tx,ty) + note;
      line.appendChild(idxEl); line.appendChild(mvEl);
      movelistEl.appendChild(line);
      movelistEl.scrollTop = movelistEl.scrollHeight;
    }

    // ===== SVG helpers =====
    function line(x1,y1,x2,y2){ const el=document.createElementNS('http://www.w3.org/2000/svg','line'); el.setAttribute('x1', x1+CELL/2); el.setAttribute('y1', y1+CELL/2); el.setAttribute('x2', x2+CELL/2); el.setAttribute('y2', y2+CELL/2); el.setAttribute('class','under'); return el; }
    function rect(x,y,w,h, attrs={}){ const el=document.createElementNS('http://www.w3.org/2000/svg','rect'); el.setAttribute('x', x); el.setAttribute('y', y); el.setAttribute('width', w); el.setAttribute('height', h); for(const k in attrs) el.setAttribute(k, attrs[k]); return el; }
    function rectCell(x,y, attrs={}){ const [dx,dy]=orient(x,y); return rect(dx*CELL+8, dy*CELL+8, CELL-16, CELL-16, attrs); }
    function circle(x,y,r, attrs={}){ const el=document.createElementNS('http://www.w3.org/2000/svg','circle'); el.setAttribute('cx', x); el.setAttribute('cy', y); el.setAttribute('r', r); for(const k in attrs) el.setAttribute(k, attrs[k]); return el; }
    function svgText(x,y,str,attrs={}){ const el=document.createElementNS('http://www.w3.org/2000/svg','text'); el.setAttribute('x', x); el.setAttribute('y', y); for(const k in attrs) el.setAttribute(k, attrs[k]); el.textContent=str; return el; }
    function tcenter(x,y,str,attrs={}){ const el=svgText(x,y,str,attrs); el.setAttribute('text-anchor','middle'); el.setAttribute('dominant-baseline','central'); el.setAttribute('alignment-baseline','central'); return el; }
    function group(attrs={}){ const el=document.createElementNS('http://www.w3.org/2000/svg','g'); for(const k in attrs) el.setAttribute(k, attrs[k]); return el; }
    function palaceLine(x1,y1,x2,y2){ const el=document.createElementNS('http://www.w3.org/2000/svg','line'); el.setAttribute('x1', x1*CELL+CELL/2); el.setAttribute('y1', y1*CELL+CELL/2); el.setAttribute('x2', x2*CELL+CELL/2); el.setAttribute('y2', y2*CELL+CELL/2); el.setAttribute('class','palace'); return el; }
    function cx(x){ return x*CELL + CELL/2; }
    function cy(y){ return y*CELL + CELL/2; }
    function orient(x,y){ return [x,y]; }
    function deorient(dx,dy){ return [dx,dy]; }
    function boardPoint(e){ const rect=boardEl.getBoundingClientRect(); const px=e.clientX-rect.left; const py=e.clientY-rect.top; const sx=px/rect.width; const sy=py/rect.height; return { x: sx*(CELL*BOARD_WIDTH), y: sy*(CELL*BOARD_HEIGHT) }; }

    // ===== AI =====
    function tryTriggerAI(){
      if(state.playMode!=='ai' || state.over) return;
      if(state.turn !== state.aiSide) return;
      if(state.aiBusy) return;
      state.aiBusy = true;
      scheduleAiTimeout();
      setTimeout(aiPlayTurn, 0);
    }
    function scheduleAiTimeout(){
      cancelAiTimeout();
      state.aiTimeoutHandle = setTimeout(()=>{ state.aiBusy=false; }, AI_TIMEOUT_MS);
    }
    function cancelAiTimeout(){
      if(state.aiTimeoutHandle){ clearTimeout(state.aiTimeoutHandle); state.aiTimeoutHandle=null; }
    }

    function aiPlayTurn(){
      if(state.over){ state.aiBusy=false; cancelAiTimeout(); return; }
      if(state.turn !== state.aiSide){ state.aiBusy=false; cancelAiTimeout(); return; }

      const side = state.turn;
      const sc = state.skill[side];
      const locked = sc.skillLockForThisTurn;

      if(state.gameMode==='skill' && sc.classKey==='K'){
        if(!locked && sc.unlockBK && !sc.usedB && sc.phase==='normal'){
          const target = pickBestEnemyForK_B(side);
          if (target) {
            performK_B(side, target);
            endTurn();
            state.aiBusy=false; cancelAiTimeout(); return;
          }
        }
        if(!locked && sc.ultraUnlocked && !sc.ultraUsed && sc.phase==='normal'){
          performK_Ultra(side);
          endTurn(); 
          state.aiBusy=false; cancelAiTimeout(); return;
        }
        if(!locked && sc.unlockAK && !sc.usedA && sc.phase==='normal'){
          performK_A(side);
          endTurn();
          state.aiBusy=false; cancelAiTimeout(); return;
        }
      }else if(state.gameMode==='skill' && sc.classKey==='S'){
        if(!locked && sc.ultraUnlocked && !sc.ultraUsed && sc.phase==='normal'){
          doUltraRevive_S(side);
          endTurn();
          state.aiBusy=false; cancelAiTimeout(); return;
        }
        if(!locked && sc.unlockBS && !sc.usedB && sc.phase==='normal'){
          const tgt = pickBestEnemyForS_B(side);
          if(tgt){ sc.phase='B'; sc.bTarget=tgt; performS_B(side); endTurn(); state.aiBusy=false; cancelAiTimeout(); return; }
        }
        if(!locked && sc.unlockAS && !sc.usedA && sc.phase==='normal' && allPieceIds(side,'S').length>0){
          sc.phase='A'; sc.aLock=null; sc.aStepsLeft=3;
          while(!state.over && state.turn===side && sc.aStepsLeft>0){
            if(!sc.aLock){
              const pids = allPieceIds(side,'S');
              if(pids.length===0){ sc.phase='normal'; sc.aStepsLeft=0; sc.usedA=true; break; }
              sc.aLock = pids[0]; sc.aStepsLeft = 3;
            }
            const pos = findPieceById(sc.aLock);
            if(!pos){ sc.phase='normal'; sc.aStepsLeft=0; sc.usedA=true; break; }
            const moves = legalMoves(state.board, pos.x, pos.y);
            if(moves.length===0){ sc.phase='normal'; sc.aStepsLeft=0; sc.usedA=true; break; }
            const mv = pickBestPawnMove(moves, side);
            const cap = !!state.board[mv.y][mv.x];
            doAIMoveOnce({fx:pos.x,fy:pos.y,tx:mv.x,ty:mv.y}, {fromSkill:'A'});
            if(cap || state.over || state.turn!==side) { state.aiBusy=false; cancelAiTimeout(); return; }
            sc.aStepsLeft = Math.max(0, sc.aStepsLeft - 1);
            if(sc.aStepsLeft<=0) { state.aiBusy=false; cancelAiTimeout(); return; }
          }
          state.aiBusy=false; cancelAiTimeout(); return;
        }
      }

      const mv = state.aiDifficulty === 'veteran' ? chooseAIMoveVeteran(side) : chooseAIMoveNovice(side);
      if(!mv){ endTurn(); redraw(); state.aiBusy=false; cancelAiTimeout(); return; }
      doAIMoveOnce(mv);
      state.aiBusy=false; cancelAiTimeout();
    }
    
    function doAIMoveOnce(mv, opts={}){
      if(state.over) return;
      if(state.turn!==state.aiSide) return;

      const movingPiece = state.board[mv.fy][mv.fx];
      const target = state.board[mv.ty][mv.tx];
      
      if (state.gameMode === 'skill' && target && target.t === 'K') {
          const targetSkillClass = state.skill[target.c]?.classKey;
          if (targetSkillClass === 'K') {
              return; 
          }
      }

      state.lastStart = {x:mv.fx,y:mv.fy, c: state.turn};
      state.lastEnd = {x:mv.tx,y:mv.ty};
      state.board = applyMove(state.board, mv.fx,mv.fy, mv.tx,mv.ty);
      state.lastMove = {fx:mv.fx,fy:mv.fy,tx:mv.tx,ty:mv.ty};
      logMove(mv.fx,mv.fy,mv.tx,mv.ty, movingPiece);

      if (target && target.t === 'K' && state.skill[target.c]?.classKey !== 'B') {
          endGameByForce(movingPiece.c, '吃掉將/帥');
          redraw();
          return;
      }
      
      if (target && target.t === 'X') {
          const victimSide = target.c;
          if (allPieceIds(victimSide, 'X').length === 0) {
              state.chancellorActive[victimSide] = false;
              showToast(`${victimSide === 'r' ? '紅方' : '黑方'}的「丞」已被全滅，丞相效果消失！`);
          }
      }

      if(target && target.t==='S'){
        state.skill[target.c].lastPawnDeath = { at:{x:mv.tx,y:mv.ty}, killerType:movingPiece.t, killedByKing:(movingPiece.t==='K') };
        state.pawnLossCount[target.c] = (state.pawnLossCount[target.c]||0) + 1;
        checkUltraUnlock_S(target.c);
      }

      if(state.gameMode==='skill'){
        const sc = state.skill[state.turn];
        if(movingPiece.t==='S' && opts.fromSkill!=='A'){
          if(AI_PAWN_FAST_CHARGE){ sc.progS=sc.progMax; sc.unlockAS=true; sc.unlockBS=true; }
          else { sc.progS = Math.min(sc.progMax, sc.progS + 1); if(sc.progS>=sc.progMax){ sc.unlockAS=true; sc.unlockBS=true; } }
        }else if(movingPiece.t==='K'){
          sc.progK = Math.min(sc.progMax, sc.progK + 1); if(sc.progK>=sc.progMax){ sc.unlockAK=true; sc.unlockBK=true; }
        } else if (movingPiece.t === 'A') {
            sc.progA = Math.min(sc.progMax, sc.progA + 1); if (sc.progA >= sc.progMax) { sc.unlockAA = true; sc.unlockBA = true; }
            const oppoSc = state.skill[opposite(state.turn)];
            if (oppoSc.classKey === 'A') {
                oppoSc.ultraUnlocked = true;
                showToast('敵方解鎖必殺技：君辱神亡！');
            }
        }
      }

      endTurn();
      redraw();
    }
    
    function evaluateBoard(board, forSide){
      let score = 0;
      for(let y=0; y<BOARD_HEIGHT; y++){
        for(let x=0; x<BOARD_WIDTH; x++){
          const p = board[y][x];
          if(!p) continue;
          const value = PIECE_VALUE[p.t] || 0;
          if(p.c === forSide){
            score += value;
            if(p.t === 'S' && !onOwnSide(y, p.c)) score += 1;
          } else {
            score -= value;
            if(p.t === 'S' && !onOwnSide(y, p.c)) score -= 1;
          }
        }
      }
      return score;
    }

    function chooseAIMoveNovice(side){
      const moves=listAllLegalMoves(state.board, side);
      if(moves.length===0) return null;
      let best=[], bestScore=-1e9;
      for(const m of moves){
        let s=0;
        if(m.cap && m.capType && m.capType!=='K') s += PIECE_VALUE[m.capType]*10;
        s += -Math.abs(m.tx-4)*0.1;
        s += (side==='r' ? (9 - m.ty) : m.ty) * 0.02;
        s += Math.random()*0.01;
        if(s>bestScore-1e-9){ if(s>bestScore+1e-9){best=[m];bestScore=s;} else best.push(m); }
      }
      const pick = best[Math.floor(Math.random()*best.length)];
      return {fx:pick.fx,fy:pick.fy,tx:pick.tx,ty:pick.ty};
    }
    
    function chooseAIMoveVeteran(side){
      const moves = listAllLegalMoves(state.board, side);
      if(moves.length === 0) return null;

      let bestScore = -Infinity;
      let bestMoves = [];

      for (const move of moves) {
        const tempBoard = applyMove(state.board, move.fx, move.fy, move.tx, move.ty);
        
        const opponentKing = findGeneral(tempBoard, opposite(side));
        if (state.skill[opposite(side)]?.classKey !== 'B' && !opponentKing) return move;
        
        if (!anyLegalMoves(tempBoard, opposite(side))) {
          if (inCheck(tempBoard, opposite(side))) return move;
        }

        let worstCaseScore = Infinity;
        const opponentMoves = listAllLegalMoves(tempBoard, opposite(side));

        if (opponentMoves.length === 0) {
            worstCaseScore = Infinity; 
        } else {
            for (const opponentMove of opponentMoves) {
                const finalBoard = applyMove(tempBoard, opponentMove.fx, opponentMove.fy, opponentMove.tx, opponentMove.ty);
                const score = evaluateBoard(finalBoard, side);
                if (score < worstCaseScore) {
                    worstCaseScore = score;
                }
            }
        }

        if (worstCaseScore > bestScore) {
            bestScore = worstCaseScore;
            bestMoves = [move];
        } else if (worstCaseScore === bestScore) {
            bestMoves.push(move);
        }
      }

      return bestMoves[Math.floor(Math.random() * bestMoves.length)];
    }

    function pickBestEnemyForK_B(side) {
        const enemy = opposite(side);
        const list = [];
        for (let y = 0; y < BOARD_HEIGHT; y++) {
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const p = state.board[y][x];
                if (p && p.c === enemy && p.t !== 'K' && p.t !== 'W') {
                    list.push({x, y, score: PIECE_VALUE[p.t] || 1});
                }
            }
        }
        if (list.length === 0) return null;
        list.sort((a, b) => b.score - a.score);
        return {x: list[0].x, y: list[0].y};
    }

    function pickBestEnemyForS_B(side){
      const enemy = opposite(side);
      const list=[];
      for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){
        const p=state.board[y][x];
        if(p && p.c===enemy && p.t!=='K' && p.t!=='A' && p.t!=='W'){
          list.push({x,y,score: PIECE_VALUE[p.t]||1});
        }
      }
      if (list.length === 0) return null;
      list.sort((a,b)=> b.score - a.score);
      return list[0] ? {x:list[0].x, y:list[0].y} : null;
    }

    function findPieceById(id){
      for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){
        const p=state.board[y][x]; if(p && p.id===id) return {x,y};
      }
      return null;
    }

    function allPieceIds(side, t){
      const ids=[];
      for(let y=0;y<BOARD_HEIGHT;y++)for(let x=0;x<BOARD_WIDTH;x++){
        const p=state.board[y][x]; if(p && p.c===side && (!t || p.t===t)) ids.push(p.id);
      }
      return ids;
    }

    function pickBestPawnMove(moves, side){
      const scored = moves.map(m=>{
        let s = 0;
        if(m.cap) s += 5;
        s += (side==='r' ? (9 - m.y) : m.y) * 0.2;
        s -= Math.abs(m.x-4)*0.05;
        return {m, s};
      });
      scored.sort((a,b)=> b.s - a.s);
      return (scored[0]||{}).m || moves[0];
    }

    // ===== Home / UI =====
    function renderSkillGridWithName(container, name){
      container.innerHTML='';
      CLASSES.forEach(label=>{
        const key = CLASS_KEY[label];
        const supported = SUPPORT_CLASS.has(label);
        const wrap = document.createElement('label');
        wrap.className = 'skillcard' + (supported?'':' disabled');
        const row1 = document.createElement('div');
        const input = document.createElement('input');
        input.type='radio'; input.name=name; input.value=key; input.disabled = !supported;
        if(supported && key==='S'){ input.checked = true; }
        const titleEl = document.createElement('span'); titleEl.className='title'; titleEl.textContent = label;
        row1.appendChild(input); row1.appendChild(titleEl);
        const desc = document.createElement('div'); desc.className='desc';
        desc.textContent = supported ? '' : '尚未開放';
        wrap.appendChild(row1); wrap.appendChild(desc);
        container.appendChild(wrap);
      });
    }

    tabBasic.addEventListener('click', ()=>{
      tabBasic.classList.add('active'); tabSkill.classList.remove('active'); tabGuide.classList.remove('active');
      basicPane.style.display='block'; skillPane.style.display='none'; guidePane.style.display='none';
    });
    tabSkill.addEventListener('click', ()=>{
      tabSkill.classList.add('active'); tabBasic.classList.remove('active'); tabGuide.classList.remove('active');
      basicPane.style.display='none'; skillPane.style.display='block'; guidePane.style.display='none';
    });
    tabGuide.addEventListener('click', ()=>{
      tabGuide.classList.add('active'); tabBasic.classList.remove('active'); tabSkill.classList.remove('active');
      basicPane.style.display='none'; skillPane.style.display='none'; guidePane.style.display='block';
    });

    basicLocal.addEventListener('click', ()=>{
      startGame({gameMode:'basic', playMode:'local', first:'human'});
    });
    basicAI.addEventListener('click', ()=>{
      const first = document.querySelector('input[name="basicFirst"]:checked')?.value || 'human';
      const difficulty = document.querySelector('input[name="basicDifficulty"]:checked')?.value || 'novice';
      startGame({gameMode:'basic', playMode:'ai', first, difficulty});
    });

    skillLocalStart.addEventListener('click', ()=>{
      const p1 = document.querySelector('input[name="p1Skill"]:checked')?.value || 'S';
      const p2 = document.querySelector('input[name="p2Skill"]:checked')?.value || 'S';
      startGame({gameMode:'skill', playMode:'local', first:'human', skillSel:{ r:p1, b:p2 }});
    });
    skillAIStart.addEventListener('click', ()=>{
      const sel = document.querySelector('input[name="aiSkill"]:checked')?.value || 'S';
      const first = document.querySelector('input[name="skillFirst"]:checked')?.value || 'human';
      const difficulty = document.querySelector('input[name="skillDifficulty"]:checked')?.value || 'novice';
      const skillSel = { r:sel, b:sel };
      startGame({gameMode:'skill', playMode:'ai', first, skillSel, difficulty});
    });

    homeBtn.addEventListener('click', backHome);
    newBtn.addEventListener('click', newGame);
    coordTgl?.addEventListener('change', ()=>{ state.showCoords = coordTgl.checked; drawCoords(); });

    skipBtn.addEventListener('click', ()=>{
      if(state.over || (state.playMode==='ai' && state.turn===state.aiSide)) return;
      const sc = state.skill[state.turn];
      if (sc.classKey !== 'B') return;
      
      sc.progB = Math.min(5, sc.progB + 1);
      if (sc.progB >= 5) {
        sc.unlockAB = true;
        sc.unlockBB = true;
      }
      logMove(null,null,null,null, {c:state.turn, t:'B'}, '(跳過)');
      endTurn();
      redraw();
    });

    // === Skill Buttons Events ===
    btnA.addEventListener('click', ()=>{
      if(state.gameMode!=='skill' || state.over) return;
      if(state.playMode==='ai' && state.turn===state.aiSide) return;
      const sc = state.skill[state.turn];
      if(sc.classKey==='S'){
        if(sc.unlockAS && !sc.usedA && sc.phase==='normal'){
          sc.phase='A'; sc.aLock=null; sc.aStepsLeft=3;
          showToast('三步登天：選擇你的兵，依序走至多 3 步；吃子立即結束');
          renderSkillBar(); redraw();
        }
      }else if(sc.classKey==='K'){
        if(sc.unlockAK && !sc.usedA && sc.phase==='normal'){
          performK_A(state.turn);
          endTurn(); 
          redraw();
        }
      } else if(sc.classKey==='C'){
        if(sc.unlockAC && !sc.usedA && sc.phase==='normal'){
          performC_A(state.turn);
          redraw();
        }
      } else if(sc.classKey==='E'){
          if(sc.unlockAE && !sc.usedA && sc.phase==='normal'){
              performE_A(state.turn);
              endTurn();
              redraw();
          }
      } else if(sc.classKey==='A'){
          if(sc.unlockAA && !sc.usedA && sc.phase==='normal'){
              performA_A(state.turn);
              redraw();
              renderSkillBar();
          }
      } else if (sc.classKey === 'B') {
        if(sc.unlockAB && !sc.usedA && sc.phase==='normal'){
          performBiao_A(state.turn);
        }
      }
    });

    btnB.addEventListener('click', ()=>{
      if(state.gameMode!=='skill' || state.over) return;
      if(state.playMode==='ai' && state.turn===state.aiSide) return;
      const sc = state.skill[state.turn];
      if(sc.classKey==='S'){
        if(sc.unlockBS && !sc.usedB && sc.phase==='normal'){
          sc.phase='B';
          showToast('指敵為友：點擊一枚可轉化的敵子');
          renderSkillBar(); redraw();
        }
      }else if(sc.classKey==='K'){
        if(sc.unlockBK && !sc.usedB && sc.phase==='normal'){
          sc.phase='B';
          showToast('替身司令：選擇一枚敵子（將/帥除外）進行替換');
          renderSkillBar(); redraw();
        }
      } else if(sc.classKey==='C'){
        if(sc.unlockBC && !sc.usedB && sc.phase==='normal'){
          sc.phase='B';
          showToast('意不意外：選擇一枚敵子作為中心引爆');
          renderSkillBar(); redraw();
        }
      } else if(sc.classKey==='E'){
          if(sc.unlockBE && !sc.usedB && sc.phase==='normal'){
              performE_B(state.turn);
              endTurn();
              redraw();
          }
      } else if(sc.classKey==='A'){
          if(sc.unlockBA && !sc.usedB && sc.phase==='normal'){
              performA_B(state.turn);
              endTurn();
              redraw();
          }
      } else if (sc.classKey === 'B') {
        if(sc.unlockBB && !sc.usedB && sc.phase==='normal'){
          performBiao_B(state.turn);
        }
      }
    });

    btnUltra.addEventListener('click', ()=>{
      if(state.gameMode!=='skill' || state.over) return;
      if(state.playMode==='ai' && state.turn===state.aiSide) return;
      const sc = state.skill[state.turn];
      if(sc.ultraUnlocked && !sc.ultraUsed && sc.phase==='normal'){
        if(sc.classKey==='S'){
          doUltraRevive_S(state.turn);
          endTurn();
          redraw();
        }else if(sc.classKey==='K'){
          performK_Ultra(state.turn);
          endTurn();
          redraw();
        } else if(sc.classKey==='C'){
          performC_Ultra(state.turn);
          endTurn();
          redraw();
        } else if(sc.classKey==='E'){
            performE_Ultra(state.turn);
            endTurn();
            redraw();
        } else if(sc.classKey==='A'){
            performA_Ultra(state.turn);
            endTurn();
            redraw();
        } else if (sc.classKey === 'B') {
            performBiao_Ultra(state.turn);
        }
      }
    });

    function startGame({gameMode, playMode, first, skillSel, difficulty = 'novice'}){
      state = { ...state, // keep some settings like showCoords
          board: deepClone(START),
          turn: 'r', turnCount: 0, selected: null, legal: [],
          lastMove: null, lastStart:null, lastEnd:null,
          over: false, history: [],
          gameMode, playMode, aiSide: (playMode==='ai' ? (first==='human'?'b':'r') : null), aiDifficulty: difficulty,
          skillChoice: { r:null, b:null },
          skill: { r: newSkillState(), b: newSkillState() },
          grass: [], poisonMistInfo: [], tempCannonTransforms: [],
          chancellorActive: { r: false, b: false },
          advisorCanLeavePalace: { r: false, b: false },
          palaceRestrictionFor: null,
          isGhost: { r: false, b: false },
          forceKingMoveFor: null,
          pawnLossCount: { r:0, b:0 },
          aiBusy: false, aiTimeoutHandle: null
      };
      
      movelistEl.innerHTML = '';
      statusMsg.textContent=''; statusMsg.className='msg';
      cancelAiTimeout();

      if(gameMode==='guide'){
        backHome(); tabGuide.click(); modeChip.textContent='說明模式'; return;
      }

      skipBtn.style.display = 'none';

      if(gameMode==='basic'){
        undoBtn.style.display='inline-block';
        modeChip.textContent=`基本模式 (${difficulty==='novice'?'新手':'老手'})`;
        skillBar.style.display='none';
        legendEl.classList.remove('skill');
      }else{
        undoBtn.style.display='none';
        const difficultyText = playMode === 'ai' ? ` (${difficulty==='novice'?'新手':'老手'})` : '';
        modeChip.textContent=`技能模式${difficultyText}`;
        skillBar.style.display='flex';
        legendEl.classList.add('skill');
        if(playMode==='local'){
          state.skillChoice.r = skillSel?.r || 'S';
          state.skillChoice.b = skillSel?.b || 'S';
        }else{
          const sel = skillSel?.r || 'S';
          state.skillChoice.r = sel; state.skillChoice.b = sel;
        }
        state.skill.r.classKey = state.skillChoice.r;
        state.skill.b.classKey = state.skillChoice.b;
        
        // Biao class setup
        ['r', 'b'].forEach(side => {
          if (state.skill[side].classKey === 'B') {
              if (state.turn === side && state.turn !== state.aiSide) skipBtn.style.display = 'inline-block';
              state.skill[side].progMax = 5;
              state.skill[side].ultraUnlocked = true;
              
              const biaoY = side === 'r' ? 8 : 1;
              state.board[biaoY][4] = {c: side, t: 'B', id: 'biao_' + side};
              
              for(let y=0; y<BOARD_HEIGHT; y++) for(let x=0; x<BOARD_WIDTH; x++) {
                if(state.board[y][x]?.c === side && state.board[y][x]?.t === 'A') {
                  state.board[y][x] = null;
                }
              }
          }
        });
      }
      
      if (state.skill[state.turn].classKey === 'B' && state.turn !== state.aiSide) {
        skipBtn.style.display = 'inline-block';
      }

      homeView.style.display='none'; appView.style.display='block'; guideView.style.display='none';
      drawGrid();
      refreshAllUltraUnlock();
      redraw();

      if(playMode==='ai' && first==='ai'){ tryTriggerAI(); }
    }

    function newGame(){
      const g=state.gameMode, p=state.playMode, d=state.aiDifficulty;
      if(g==='guide'){ backHome(); return; }
      const first = (p==='ai' && state.aiSide==='r') ? 'ai' : 'human';
      const skillSel = { r: state.skillChoice.r||'S', b: state.skillChoice.b||'S' };
      startGame({gameMode:g, playMode:p, first, skillSel, difficulty:d});
    }

    function backHome(){
      appView.style.display='none'; homeView.style.display='block'; guideView.style.display='none';
      modeChip.textContent='請選擇模式';
      cancelAiTimeout(); state.aiBusy=false;
    }

    // ===== Undo (basic only) =====
    undoBtn.addEventListener('click', undo);
    function pushHistory(){
      if(state.gameMode!=='basic') return;
      state.history.push({
        board: deepClone(state.board),
        turn: state.turn,
        lastMove: state.lastMove?{...state.lastMove}:null,
        lastStart: state.lastStart?{...state.lastStart}:null,
        lastEnd: state.lastEnd?{...state.lastEnd}:null,
        over: state.over,
        movesCount: movelistEl.children.length
      });
    }
    function undo(){
      if(state.gameMode!=='basic') return;
      const last = state.history.pop();
      if(!last) return;
      state.board = last.board;
      state.turn = last.turn;
      state.lastMove = last.lastMove;
      state.lastStart = last.lastStart;
      state.lastEnd = last.lastEnd;
      state.over = last.over;
      while(movelistEl.children.length > last.movesCount) movelistEl.lastElementChild.remove();
      redraw();
    }

    // ===== Toast & Helpers =====
    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      setTimeout(()=> toastEl.classList.remove('show'), 1700);
    }
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

    // ===== Init =====
    function renderSkillGridStart(){
      renderSkillGridWithName(p1Skills, 'p1Skill');
      renderSkillGridWithName(p2Skills, 'p2Skill');
      renderSkillGridWithName(aiSkillGrid, 'aiSkill');
    }
    renderSkillGridStart();
    drawGrid();
    redraw();

    // Debug
    window._xi = { state, startGame };
  </script>
</body>
</html>