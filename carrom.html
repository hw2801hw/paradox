<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Carrom å¡ç¾…å§†å½ˆç›¤éŠæˆ²</title>
    <!--
    ========================================
    CARROM å¡ç¾…å§†å½ˆç›¤éŠæˆ² - éŠæˆ²èªªæ˜
    ========================================
    
    ã€éŠæˆ²è¦å‰‡ã€‘
    1. å…©ä½ç©å®¶è¼ªæµæ“ä½œï¼Œç©å®¶1æ§åˆ¶ç™½è‰²ç›¤å­ï¼Œç©å®¶2æ§åˆ¶é»‘è‰²ç›¤å­
    2. ä½¿ç”¨æ“Šçƒå™¨ï¼ˆStrikerï¼‰å°‡è‡ªå·±é¡è‰²çš„ç›¤å­å½ˆå…¥å››å€‹è§’è½çš„æ´ä¸­
    3. ç´…è‰²çš‡åï¼ˆQueenï¼‰å¯è¢«ä»»ä¸€ç©å®¶æ“Šå…¥ï¼Œä½†å¿…é ˆç·Šæ¥è‘—æ“Šå…¥è‡ªå·±çš„ç›¤å­æ‰èƒ½ã€ŒCoverã€
    4. æˆåŠŸå°‡ç›¤å­æ“Šå…¥æ´ä¸­å¯ç¹¼çºŒæ“ä½œï¼Œå¦å‰‡æ›å°æ‰‹
    5. å…ˆå°‡æ‰€æœ‰å·±æ–¹ç›¤å­æ“Šå…¥æ´ä¸­çš„ç©å®¶ç²å‹
    
    ã€å¤©è³¦ç³»çµ±ã€‘
    é–‹å±€æ™‚æ¯ä½ç©å®¶é¸æ“‡ä¸€å€‹å¤©è³¦ï¼š
    - ä¸€è§¸å³ç™¼ï¼šåŠ›åº¦å’Œç„æº–ç·š+300%ï¼ˆå¯é è¦½åå½ˆè·¯å¾‘ï¼‰ï¼Œå°æ‰‹-30%
    - èº«ä¸ç”±å·±ï¼šå°æ‰‹é€²çƒä¸èƒ½é€£çºŒå›åˆï¼Œä¸”å¾å·¦å³å…©å´åŒæ™‚ç™¼å°„2å€‹çƒ
    - æ´å¯Ÿå…ˆæ©Ÿï¼šæˆ‘æ–¹å›åˆæ´+4å€‹ï¼ˆé¡å¤–æ´å¤§å°+100%ï¼‰ï¼›å°æ–¹å›åˆåªå‰©é ‚éƒ¨å’Œåº•éƒ¨æ­£ä¸­é–“çš„æ´ï¼ˆå¤§å°+50%ï¼‰ï¼Œç„¡å…¶ä»–æ´
    
    ã€æ“ä½œæ–¹å¼ã€‘
    - æ‹–æ‹½æ“Šçƒå™¨ï¼šåœ¨åŸºç·šä¸Šå·¦å³ç§»å‹•æ“Šçƒå™¨ä½ç½®
    - ç„æº–ç™¼å°„ï¼šæŒ‰ä½æ“Šçƒå™¨ä¸¦å‘å¾Œæ‹–æ‹½ï¼Œé¡¯ç¤ºç„æº–ç·šå’ŒåŠ›é‡æ¢ï¼Œæ”¾é–‹ç™¼å°„
    - åŠ›é‡æ§åˆ¶ï¼šæ‹–æ‹½è·é›¢è¶Šé•·ï¼Œç™¼å°„åŠ›é‡è¶Šå¤§
    ========================================
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #gameCanvas {
            display: block;
            background: #2d2d44;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            z-index: 10;
            align-items: center;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .player-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
        }
        
        .player-info.active {
            background: rgba(255,255,255,0.2);
            padding: 5px 12px;
            border-radius: 15px;
            margin: -5px -12px;
        }
        
        #menuBtn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        #menuBtn:hover, #menuBtn:active {
            background: rgba(255,255,255,0.3);
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            overflow-y: auto;
            padding: 20px;
        }
        
        #overlay.hidden {
            display: none;
        }
        
        #overlay h1 {
            color: #ffd700;
            font-size: 42px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        #overlay h2 {
            color: #fff;
            font-size: 24px;
            margin-bottom: 20px;
            font-weight: normal;
        }
        
        #overlay h3 {
            color: #ffd700;
            font-size: 20px;
            margin: 15px 0 10px 0;
        }
        
        .menu-btn {
            background: linear-gradient(145deg, #4a6741, #3d5636);
            color: white;
            border: none;
            padding: 18px 45px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            min-width: 220px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        
        .menu-btn:hover, .menu-btn:active {
            background: linear-gradient(145deg, #5a7a51, #4d6846);
            transform: scale(1.05);
        }
        
        .talent-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            max-width: 900px;
            margin: 10px 0;
        }
        
        .talent-card {
            background: linear-gradient(145deg, #2a3a50, #1e2a3a);
            border: 3px solid #3a4a60;
            border-radius: 15px;
            padding: 15px;
            width: 260px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }
        
        .talent-card:hover {
            border-color: #ffd700;
            transform: translateY(-5px);
        }
        
        .talent-card.selected {
            border-color: #4ade80;
            background: linear-gradient(145deg, #2a4a3a, #1e3a2a);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }
        
        .talent-card h4 {
            color: #ffd700;
            font-size: 18px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .talent-card p {
            color: #ccc;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .talent-icon {
            font-size: 24px;
        }
        
        #message {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #ffd700;
            padding: 12px 25px;
            border-radius: 20px;
            font-size: 16px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
            max-width: 90%;
        }
        
        #message.show {
            opacity: 1;
        }
        
        #turnIndicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 16px;
            z-index: 10;
        }
        
        .winner-text {
            font-size: 28px !important;
            color: #4ade80 !important;
        }
        
        .talent-display {
            font-size: 12px;
            color: #aaa;
            margin-left: 10px;
        }
        
        .confirm-dialog {
            background: rgba(0,0,0,0.95);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        
        .confirm-dialog.hidden {
            display: none;
        }
        
        .confirm-dialog p {
            color: white;
            font-size: 22px;
            margin-bottom: 30px;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 20px;
        }
        
        .confirm-btn {
            padding: 15px 40px;
            font-size: 18px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .confirm-btn.yes {
            background: #ef4444;
            color: white;
        }
        
        .confirm-btn.no {
            background: #4a6741;
            color: white;
        }
        
        .confirm-btn:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui" class="hidden">
            <button id="menuBtn" onclick="showExitConfirm()">â˜° é¸å–®</button>
            <div class="player-info" id="player1Info">
                <div class="player-dot" style="background: #f5f5dc;"></div>
                <span>P1: <span id="score1">0</span></span>
                <span class="talent-display" id="talent1Display"></span>
            </div>
            <div class="player-info" id="player2Info">
                <div class="player-dot" style="background: #2d2d2d;"></div>
                <span>P2: <span id="score2">0</span></span>
                <span class="talent-display" id="talent2Display"></span>
            </div>
        </div>
        <div id="message"></div>
        <div id="turnIndicator" class="hidden">ç©å®¶1 çš„å›åˆ</div>
        
        <div id="confirmDialog" class="confirm-dialog hidden">
            <p>ç¢ºå®šè¦è¿”å›ä¸»é¸å–®å—ï¼Ÿ</p>
            <div class="confirm-buttons">
                <button class="confirm-btn yes" onclick="confirmExit()">ç¢ºå®š</button>
                <button class="confirm-btn no" onclick="cancelExit()">å–æ¶ˆ</button>
            </div>
        </div>
        
        <div id="overlay">
            <h1>ğŸ¯ CARROM</h1>
            <h2>å¡ç¾…å§†å½ˆç›¤éŠæˆ²</h2>
            <button class="menu-btn" onclick="selectMode('pvp')">ğŸ‘¥ é›™äººå°æˆ°</button>
            <button class="menu-btn" onclick="selectMode('ai')">ğŸ¤– å–®äºº vs AI</button>
        </div>
    </div>

    <script>
        // ========== éŠæˆ²é…ç½® ==========
        const CONFIG = {
            friction: 0.985,
            restitution: 0.75,
            basePocketRadius: 22,
            pieceRadius: 14,
            strikerRadius: 18,
            queenRadius: 14,
            maxPower: 25,
            minSpeed: 0.15,
            baseAimLength: 200
        };

        // ========== å¤©è³¦ç³»çµ± ==========
        const TALENTS = {
            precision: {
                id: 'precision',
                name: 'ä¸€è§¸å³ç™¼',
                icon: 'ğŸ¯',
                desc: 'æˆ‘æ–¹åŠ›åº¦å’Œç„æº–ç·š+300%ï¼ˆå¯é è¦½åå½ˆè·¯å¾‘ï¼‰ï¼Œå°æ–¹åŠ›åº¦å’Œç„æº–ç·š-30%'
            },
            rhythm: {
                id: 'rhythm',
                name: 'èº«ä¸ç”±å·±',
                icon: 'ğŸ”’',
                desc: 'å°æ–¹é€²çƒä¸èƒ½é€£çºŒå›åˆï¼Œä¸”å¾å·¦å³å…©å´åŒæ™‚ç™¼å°„2å€‹çƒ'
            },
            holes: {
                id: 'holes',
                name: 'æ´å¯Ÿå…ˆæ©Ÿ',
                icon: 'ğŸ•³ï¸',
                desc: 'æˆ‘æ–¹å›åˆï¼šæ´+4å€‹ï¼ˆé¡å¤–æ´å¤§å°+100%ï¼‰ï¼›å°æ–¹å›åˆï¼šåªå‰©é ‚éƒ¨å’Œåº•éƒ¨æ­£ä¸­é–“çš„æ´ï¼ˆå¤§å°+50%ï¼‰ï¼Œç„¡å…¶ä»–æ´'
            }
        };

        // ========== éŸ³æ•ˆç³»çµ± ==========
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            try {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                if (type === 'hit') {
                    oscillator.frequency.value = 200 + Math.random() * 100;
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.1);
                } else if (type === 'pocket') {
                    oscillator.frequency.value = 150;
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.2);
                } else if (type === 'wall') {
                    oscillator.frequency.value = 400;
                    gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.05);
                }
            } catch (e) {}
        }

        // ========== éŠæˆ²ç‹€æ…‹ ==========
        let canvas, ctx;
        let boardSize, boardX, boardY, innerSize, innerX, innerY;
        let pieces = [];
        let striker = null;
        let striker2 = null; // ç¬¬äºŒå€‹æ“Šçƒå™¨ï¼ˆèº«ä¸ç”±å·±å¤©è³¦ï¼‰
        let basePockets = [];
        let currentPockets = [];
        let gameMode = 'pvp';
        let currentPlayer = 1;
        let scores = [0, 0];
        let pocketed = { white: 0, black: 0, queen: false };
        let queenPocketedBy = 0;
        let needCover = false;
        let gameOver = false;
        let isMoving = false;
        let strikerBaseY = 0;
        let strikerMinX = 0;
        let strikerMaxX = 0;

        // å¤©è³¦ç‹€æ…‹
        let playerTalents = [null, null]; // [player1 talent, player2 talent]
        let talentSelectionPhase = 0; // 0: not selecting, 1: player1 selecting, 2: player2 selecting
        let selectedTalentTemp = null;
        let hasDualStrikers = false; // æ˜¯å¦æœ‰é›™æ“Šçƒå™¨æ¨¡å¼

        // å›åˆè¿½è¹¤ - ä¿®å¾©é€£çºŒå›åˆçš„bug
        let pocketedThisTurn = { white: 0, black: 0, queen: false, striker: false };

        // æ‹–æ‹½ç‹€æ…‹
        let isDragging = false;
        let isAiming = false;
        let dragStart = { x: 0, y: 0 };
        let aimEnd = { x: 0, y: 0 };
        let power = 0;

        // ========== åˆå§‹åŒ– ==========
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // äº‹ä»¶ç›£è½
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            canvas.addEventListener('touchend', handleEnd, { passive: false });
            
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = container.clientWidth - 20;
            const maxHeight = container.clientHeight - 100;
            
            boardSize = Math.min(maxWidth, maxHeight, 600);
            canvas.width = boardSize;
            canvas.height = boardSize;
            
            innerSize = boardSize * 0.85;
            boardX = (boardSize - innerSize) / 2;
            boardY = (boardSize - innerSize) / 2;
            innerX = boardX;
            innerY = boardY;
            
            // åŸºç¤è¢‹å£ä½ç½®ï¼ˆå››å€‹è§’ï¼‰
            const pocketOffset = boardSize * 0.08;
            basePockets = [
                { x: pocketOffset, y: pocketOffset, type: 'corner' },
                { x: boardSize - pocketOffset, y: pocketOffset, type: 'corner' },
                { x: pocketOffset, y: boardSize - pocketOffset, type: 'corner' },
                { x: boardSize - pocketOffset, y: boardSize - pocketOffset, type: 'corner' }
            ];
            
            updatePocketsForCurrentPlayer();
            
            if (striker) {
                resetStriker();
            }
        }

        // ========== é¸å–®ç³»çµ± ==========
        function showExitConfirm() {
            document.getElementById('confirmDialog').classList.remove('hidden');
        }

        function cancelExit() {
            document.getElementById('confirmDialog').classList.add('hidden');
        }

        function confirmExit() {
            document.getElementById('confirmDialog').classList.add('hidden');
            returnToMainMenu();
        }

        function returnToMainMenu() {
            gameOver = true;
            isMoving = false;
            talentSelectionPhase = 0;
            playerTalents = [null, null];
            
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('turnIndicator').classList.add('hidden');
            
            const overlay = document.getElementById('overlay');
            overlay.innerHTML = `
                <h1>ğŸ¯ CARROM</h1>
                <h2>å¡ç¾…å§†å½ˆç›¤éŠæˆ²</h2>
                <button class="menu-btn" onclick="selectMode('pvp')">ğŸ‘¥ é›™äººå°æˆ°</button>
                <button class="menu-btn" onclick="selectMode('ai')">ğŸ¤– å–®äºº vs AI</button>
            `;
            overlay.classList.remove('hidden');
        }

        function selectMode(mode) {
            initAudio();
            gameMode = mode;
            talentSelectionPhase = 1;
            selectedTalentTemp = null;
            showTalentSelection(1);
        }

        function showTalentSelection(player) {
            const overlay = document.getElementById('overlay');
            const playerName = gameMode === 'ai' && player === 2 ? 'AI' : `ç©å®¶ ${player}`;
            const playerColor = player === 1 ? '#f5f5dc' : '#2d2d2d';
            
            // AIè‡ªå‹•é¸æ“‡å¤©è³¦
            if (gameMode === 'ai' && player === 2) {
                const talentKeys = Object.keys(TALENTS);
                const randomTalent = talentKeys[Math.floor(Math.random() * talentKeys.length)];
                playerTalents[1] = randomTalent;
                startGame();
                return;
            }
            
            overlay.innerHTML = `
                <h2 style="display: flex; align-items: center; gap: 10px;">
                    <span style="display: inline-block; width: 24px; height: 24px; border-radius: 50%; background: ${playerColor}; border: 2px solid white;"></span>
                    ${playerName} é¸æ“‡å¤©è³¦
                </h2>
                <div class="talent-container">
                    ${Object.values(TALENTS).map(t => `
                        <div class="talent-card" id="talent-${t.id}" onclick="selectTalent('${t.id}')">
                            <h4><span class="talent-icon">${t.icon}</span> ${t.name}</h4>
                            <p>${t.desc}</p>
                        </div>
                    `).join('')}
                </div>
                <button class="menu-btn" id="confirmTalentBtn" onclick="confirmTalent()" style="opacity: 0.5; pointer-events: none;">
                    ç¢ºèªé¸æ“‡
                </button>
            `;
        }

        function selectTalent(talentId) {
            selectedTalentTemp = talentId;
            
            // æ›´æ–°UI
            document.querySelectorAll('.talent-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById(`talent-${talentId}`).classList.add('selected');
            
            const confirmBtn = document.getElementById('confirmTalentBtn');
            confirmBtn.style.opacity = '1';
            confirmBtn.style.pointerEvents = 'auto';
        }

        function confirmTalent() {
            if (!selectedTalentTemp) return;
            
            if (talentSelectionPhase === 1) {
                playerTalents[0] = selectedTalentTemp;
                talentSelectionPhase = 2;
                selectedTalentTemp = null;
                showTalentSelection(2);
            } else if (talentSelectionPhase === 2) {
                playerTalents[1] = selectedTalentTemp;
                talentSelectionPhase = 0;
                startGame();
            }
        }

        function startGame() {
            currentPlayer = 1;
            scores = [0, 0];
            pocketed = { white: 0, black: 0, queen: false };
            queenPocketedBy = 0;
            needCover = false;
            gameOver = false;
            pocketedThisTurn = { white: 0, black: 0, queen: false, striker: false };
            
            setupPieces();
            resetStriker();
            updatePocketsForCurrentPlayer();
            updateUI();
            
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('turnIndicator').classList.remove('hidden');
            
            // é¡¯ç¤ºå¤©è³¦
            const t1 = TALENTS[playerTalents[0]];
            const t2 = TALENTS[playerTalents[1]];
            document.getElementById('talent1Display').textContent = t1 ? t1.icon : '';
            document.getElementById('talent2Display').textContent = t2 ? t2.icon : '';
            
            showMessage(`éŠæˆ²é–‹å§‹ï¼P1:${t1?.name || 'ç„¡'} vs P2:${t2?.name || 'ç„¡'}`);
        }

        function setupPieces() {
            pieces = [];
            const center = boardSize / 2;
            const spacing = CONFIG.pieceRadius * 2.3;
            
            // ä¸­å¿ƒçš‡å
            pieces.push({
                x: center,
                y: center,
                vx: 0,
                vy: 0,
                radius: CONFIG.queenRadius,
                type: 'queen',
                color: '#dc2626'
            });
            
            // åœ“å½¢æ’åˆ—ç›¤å­
            const rings = [
                { count: 6, radius: spacing },
                { count: 12, radius: spacing * 2 }
            ];
            
            let whiteCount = 0, blackCount = 0;
            
            rings.forEach((ring, ringIndex) => {
                for (let i = 0; i < ring.count; i++) {
                    const angle = (i / ring.count) * Math.PI * 2 - Math.PI / 2;
                    const x = center + Math.cos(angle) * ring.radius;
                    const y = center + Math.sin(angle) * ring.radius;
                    
                    let type, color;
                    if (ringIndex === 0) {
                        type = i % 2 === 0 ? 'white' : 'black';
                    } else {
                        if (whiteCount < 6 && (i % 2 === 0 || blackCount >= 6)) {
                            type = 'white';
                            whiteCount++;
                        } else if (blackCount < 6) {
                            type = 'black';
                            blackCount++;
                        } else {
                            type = 'white';
                        }
                    }
                    
                    color = type === 'white' ? '#f5f5dc' : '#2d2d2d';
                    
                    pieces.push({
                        x, y, vx: 0, vy: 0,
                        radius: CONFIG.pieceRadius,
                        type, color
                    });
                }
            });
        }

        function resetStriker() {
            const baselineOffset = innerSize * 0.22;
            strikerBaseY = currentPlayer === 1 
                ? innerY + innerSize - baselineOffset 
                : innerY + baselineOffset;
            
            // æª¢æŸ¥å°æ‰‹æ˜¯å¦æœ‰èº«ä¸ç”±å·±å¤©è³¦ï¼ˆå½±éŸ¿ç•¶å‰ç©å®¶ï¼‰
            const opponentTalent = playerTalents[currentPlayer === 1 ? 1 : 0];
            hasDualStrikers = opponentTalent === 'rhythm';
            
            if (hasDualStrikers) {
                // é›™æ“Šçƒå™¨æ¨¡å¼ï¼šå›ºå®šåœ¨å·¦å³å…©å´
                const leftX = innerX + innerSize * 0.25;
                const rightX = innerX + innerSize * 0.75;
                
                striker = {
                    x: leftX,
                    y: strikerBaseY,
                    vx: 0,
                    vy: 0,
                    radius: CONFIG.strikerRadius,
                    type: 'striker',
                    color: '#fbbf24'
                };
                
                striker2 = {
                    x: rightX,
                    y: strikerBaseY,
                    vx: 0,
                    vy: 0,
                    radius: CONFIG.strikerRadius,
                    type: 'striker2',
                    color: '#fb923c'
                };
                
                strikerMinX = leftX;
                strikerMaxX = leftX;
            } else {
                // å–®æ“Šçƒå™¨æ¨¡å¼
                strikerMinX = innerX + innerSize * 0.2;
                strikerMaxX = innerX + innerSize * 0.8;
                
                striker = {
                    x: boardSize / 2,
                    y: strikerBaseY,
                    vx: 0,
                    vy: 0,
                    radius: CONFIG.strikerRadius,
                    type: 'striker',
                    color: '#fbbf24'
                };
                
                striker2 = null;
            }
            
            isDragging = false;
            isAiming = false;
        }

        // ========== å¤©è³¦æ•ˆæœï¼šæ›´æ–°è¢‹å£ ==========
        function updatePocketsForCurrentPlayer() {
            const pocketOffset = boardSize * 0.08;
            const center = boardSize / 2;
            const myTalent = playerTalents[currentPlayer - 1];
            const opponentTalent = playerTalents[currentPlayer === 1 ? 1 : 0];
            
            // æª¢æŸ¥æ´å¯Ÿå…ˆæ©Ÿå¤©è³¦
            let useExtraPockets = false;
            let limitedPockets = false;
            
            if (myTalent === 'holes') {
                useExtraPockets = true;
            }
            
            if (opponentTalent === 'holes') {
                limitedPockets = true;
            }
            
            currentPockets = [];
            
            if (limitedPockets) {
                // å°æ–¹æœ‰æ´å¯Ÿå…ˆæ©Ÿï¼šåªå‰©é ‚éƒ¨å’Œåº•éƒ¨çš„æ­£ä¸­é–“ä½ç½®çš„æ´ï¼Œå¤§å°+50%
                const limitSize = CONFIG.basePocketRadius * 1.5; // +50%

                // é ‚éƒ¨æ­£ä¸­é–“ (Top Center)
                currentPockets.push({ x: center, y: pocketOffset, size: limitSize, extra: true });
                
                // åº•éƒ¨æ­£ä¸­é–“ (Bottom Center)
                currentPockets.push({ x: center, y: boardSize - pocketOffset, size: limitSize, extra: true });

            } else {
                // æ¨™æº–æ¨¡å¼ï¼šå››å€‹è§’è½
                const size = CONFIG.basePocketRadius;
                currentPockets.push({ x: pocketOffset, y: pocketOffset, size });
                currentPockets.push({ x: boardSize - pocketOffset, y: pocketOffset, size });
                currentPockets.push({ x: pocketOffset, y: boardSize - pocketOffset, size });
                currentPockets.push({ x: boardSize - pocketOffset, y: boardSize - pocketOffset, size });
                
                // æˆ‘æ–¹å¤©è³¦ï¼šé¡å¤–4å€‹æ´ï¼ˆä¸Šä¸‹å·¦å³ä¸­é–“ï¼‰- å¤§å°+100%
                if (useExtraPockets) {
                    const extraSize = CONFIG.basePocketRadius * 2; // +100%
                    currentPockets.push({ x: center, y: pocketOffset, size: extraSize, extra: true }); // ä¸Š
                    currentPockets.push({ x: center, y: boardSize - pocketOffset, size: extraSize, extra: true }); // ä¸‹
                    currentPockets.push({ x: pocketOffset, y: center, size: extraSize, extra: true }); // å·¦
                    currentPockets.push({ x: boardSize - pocketOffset, y: center, size: extraSize, extra: true }); // å³
                }
            }
        }

        // ========== å¤©è³¦æ•ˆæœï¼šç²å–åŠ›é‡å’Œç„æº–ç·šä¿®æ­£ ==========
        function getPowerModifier() {
            const myTalent = playerTalents[currentPlayer - 1];
            const opponentTalent = playerTalents[currentPlayer === 1 ? 1 : 0];
            
            let modifier = 1;
            
            if (myTalent === 'precision') {
                modifier *= 3; // +300%
            }
            if (opponentTalent === 'precision') {
                modifier *= 0.7; // -30%
            }
            
            return modifier;
        }

        function getAimLengthModifier() {
            return getPowerModifier(); // åŒæ¨£çš„ä¿®æ­£
        }

        // ========== è¼¸å…¥è™•ç† ==========
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left) * (canvas.width / rect.width),
                y: (clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function handleStart(e) {
            e.preventDefault();
            if (isMoving || gameOver || !striker) return;
            if (gameMode === 'ai' && currentPlayer === 2) return;
            
            const pos = getEventPos(e);
            
            // æª¢æŸ¥æ˜¯å¦é»æ“Šä»»ä¸€æ“Šçƒå™¨
            const dist = Math.hypot(pos.x - striker.x, pos.y - striker.y);
            const dist2 = striker2 ? Math.hypot(pos.x - striker2.x, pos.y - striker2.y) : Infinity;
            
            if (dist < striker.radius * 2 || dist2 < CONFIG.strikerRadius * 2) {
                isAiming = true;
                // ä½¿ç”¨ç¬¬ä¸€å€‹æ“Šçƒå™¨çš„ä½ç½®ä½œç‚ºåŸºæº–ï¼ˆé›™æ“Šçƒå™¨æ™‚å…©å€‹ä¸€èµ·ç™¼å°„ï¼‰
                dragStart = { x: striker.x, y: striker.y };
                aimEnd = pos;
            } else if (Math.abs(pos.y - strikerBaseY) < 40 && !hasDualStrikers) {
                // åªæœ‰éé›™æ“Šçƒå™¨æ¨¡å¼æ‰èƒ½æ‹–æ‹½
                isDragging = true;
                striker.x = Math.max(strikerMinX, Math.min(strikerMaxX, pos.x));
            }
        }

        function handleMove(e) {
            e.preventDefault();
            if (isMoving || gameOver || !striker) return;
            
            const pos = getEventPos(e);
            
            if (isDragging && !hasDualStrikers) {
                striker.x = Math.max(strikerMinX, Math.min(strikerMaxX, pos.x));
            } else if (isAiming) {
                aimEnd = pos;
                const dx = dragStart.x - aimEnd.x;
                const dy = dragStart.y - aimEnd.y;
                power = Math.min(Math.hypot(dx, dy) / 150, 1);
            }
        }

        function handleEnd(e) {
            e.preventDefault();
            if (isMoving || gameOver || !striker) return;
            
            if (isAiming && power > 0.05) {
                const dx = dragStart.x - aimEnd.x;
                const dy = dragStart.y - aimEnd.y;
                const angle = Math.atan2(dy, dx);
                const powerMod = getPowerModifier();
                const force = power * CONFIG.maxPower * Math.min(powerMod, 3); // é™åˆ¶å¯¦éš›åŠ›é‡æœ€å¤š3å€
                
                striker.vx = Math.cos(angle) * force;
                striker.vy = Math.sin(angle) * force;
                
                // å¦‚æœæœ‰ç¬¬äºŒå€‹æ“Šçƒå™¨ï¼ŒåŒæ™‚ç™¼å°„
                if (striker2) {
                    striker2.vx = Math.cos(angle) * force;
                    striker2.vy = Math.sin(angle) * force;
                }
                
                // é‡ç½®é€™å›åˆçš„å…¥è¢‹è¿½è¹¤
                pocketedThisTurn = { white: 0, black: 0, queen: false, striker: false };
                
                isMoving = true;
                playSound('hit');
            }
            
            isDragging = false;
            isAiming = false;
            power = 0;
        }

        // ========== ç‰©ç†ç³»çµ± ==========
        function updatePhysics() {
            if (!isMoving) return;
            
            let allPieces = [...pieces];
            if (striker) allPieces.push(striker);
            if (striker2) allPieces.push(striker2);
            
            // æ›´æ–°ä½ç½®
            allPieces.forEach(p => {
                if (p.pocketed) return;
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= CONFIG.friction;
                p.vy *= CONFIG.friction;
            });
            
            // é‚Šç•Œç¢°æ’
            allPieces.forEach(p => {
                if (p.pocketed) return;
                
                const minX = innerX + p.radius;
                const maxX = innerX + innerSize - p.radius;
                const minY = innerY + p.radius;
                const maxY = innerY + innerSize - p.radius;
                
                if (p.x < minX) { p.x = minX; p.vx *= -CONFIG.restitution; playSound('wall'); }
                if (p.x > maxX) { p.x = maxX; p.vx *= -CONFIG.restitution; playSound('wall'); }
                if (p.y < minY) { p.y = minY; p.vy *= -CONFIG.restitution; playSound('wall'); }
                if (p.y > maxY) { p.y = maxY; p.vy *= -CONFIG.restitution; playSound('wall'); }
            });
            
            // ç›¤å­é–“ç¢°æ’
            for (let i = 0; i < allPieces.length; i++) {
                for (let j = i + 1; j < allPieces.length; j++) {
                    const a = allPieces[i];
                    const b = allPieces[j];
                    if (a.pocketed || b.pocketed) continue;
                    
                    const dx = b.x - a.x;
                    const dy = b.y - a.y;
                    const dist = Math.hypot(dx, dy);
                    const minDist = a.radius + b.radius;
                    
                    if (dist < minDist && dist > 0) {
                        playSound('hit');
                        
                        // åˆ†é›¢
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        
                        a.x -= nx * overlap / 2;
                        a.y -= ny * overlap / 2;
                        b.x += nx * overlap / 2;
                        b.y += ny * overlap / 2;
                        
                        // é€Ÿåº¦äº¤æ›
                        const dvx = a.vx - b.vx;
                        const dvy = a.vy - b.vy;
                        const dot = dvx * nx + dvy * ny;
                        
                        if (dot > 0) {
                            const impulse = dot * CONFIG.restitution;
                            a.vx -= impulse * nx;
                            a.vy -= impulse * ny;
                            b.vx += impulse * nx;
                            b.vy += impulse * ny;
                        }
                    }
                }
            }
            
            // æª¢æŸ¥å…¥è¢‹
            checkPockets();
            
            // æª¢æŸ¥æ˜¯å¦åœæ­¢
            const moving = allPieces.some(p => 
                !p.pocketed && (Math.abs(p.vx) > CONFIG.minSpeed || Math.abs(p.vy) > CONFIG.minSpeed)
            );
            
            if (!moving && isMoving) {
                isMoving = false;
                handleTurnEnd();
            }
        }

        function checkPockets() {
            let allPieces = [...pieces];
            if (striker) allPieces.push(striker);
            if (striker2) allPieces.push(striker2);
            
            allPieces.forEach(piece => {
                if (piece.pocketed) return;
                
                currentPockets.forEach(pocket => {
                    const dist = Math.hypot(piece.x - pocket.x, piece.y - pocket.y);
                    if (dist < pocket.size + piece.radius * 0.3) {
                        piece.pocketed = true;
                        piece.vx = 0;
                        piece.vy = 0;
                        playSound('pocket');
                        
                        handlePocket(piece);
                    }
                });
            });
        }

        function handlePocket(piece) {
            if (piece.type === 'striker' || piece.type === 'striker2') {
                pocketedThisTurn.striker = true;
                showMessage('çŠ¯è¦ï¼æ“Šçƒå™¨å…¥è¢‹');
                scores[currentPlayer - 1] = Math.max(0, scores[currentPlayer - 1] - 1);
            } else if (piece.type === 'queen') {
                queenPocketedBy = currentPlayer;
                needCover = true;
                pocketed.queen = true;
                pocketedThisTurn.queen = true;
                showMessage('çš‡åå…¥è¢‹ï¼éœ€è¦ Cover');
            } else if (piece.type === 'white') {
                pocketed.white++;
                pocketedThisTurn.white++;
                if (currentPlayer === 1) {
                    scores[0]++;
                    if (needCover && queenPocketedBy === 1) {
                        scores[0] += 3;
                        needCover = false;
                        showMessage('Cover æˆåŠŸï¼+3 åˆ†');
                    }
                }
            } else if (piece.type === 'black') {
                pocketed.black++;
                pocketedThisTurn.black++;
                if (currentPlayer === 2) {
                    scores[1]++;
                    if (needCover && queenPocketedBy === 2) {
                        scores[1] += 3;
                        needCover = false;
                        showMessage('Cover æˆåŠŸï¼+3 åˆ†');
                    }
                }
            }
            
            updateUI();
        }

        function handleTurnEnd() {
            // æª¢æŸ¥å‹åˆ©æ¢ä»¶
            if (pocketed.white >= 9) {
                endGame(1);
                return;
            }
            if (pocketed.black >= 9) {
                endGame(2);
                return;
            }
            
            // å¦‚æœçš‡åæœªè¢« coverï¼Œæª¢æŸ¥é€™å›åˆæ˜¯å¦æœ‰cover
            if (needCover && pocketedThisTurn.queen) {
                // çš‡åé€™å›åˆå…¥è¢‹ï¼Œéœ€è¦åŒå›åˆcover
                const coveredThisTurn = (queenPocketedBy === 1 && pocketedThisTurn.white > 0) ||
                                       (queenPocketedBy === 2 && pocketedThisTurn.black > 0);
                
                if (!coveredThisTurn) {
                    const queenPiece = pieces.find(p => p.type === 'queen');
                    if (queenPiece) {
                        queenPiece.pocketed = false;
                        queenPiece.x = boardSize / 2;
                        queenPiece.y = boardSize / 2;
                        needCover = false;
                        queenPocketedBy = 0;
                        pocketed.queen = false;
                        showMessage('æœªèƒ½ Coverï¼Œçš‡åé‡ç½®');
                    }
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰å·±æ–¹ç›¤å­å…¥è¢‹ï¼ˆé€™å›åˆï¼‰
            let scoredThisTurn = false;
            if (currentPlayer === 1) {
                scoredThisTurn = pocketedThisTurn.white > 0;
            } else {
                scoredThisTurn = pocketedThisTurn.black > 0;
            }
            
            // æª¢æŸ¥å°æ‰‹çš„èº«ä¸ç”±å·±å¤©è³¦
            const opponentTalent = playerTalents[currentPlayer === 1 ? 1 : 0];
            const noConsecutiveTurn = opponentTalent === 'rhythm';
            
            // åˆ¤æ–·æ˜¯å¦æ›äºº
            const shouldSwitch = !scoredThisTurn || pocketedThisTurn.striker || noConsecutiveTurn;
            
            if (shouldSwitch) {
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updatePocketsForCurrentPlayer();
            }
            
            resetStriker();
            updateUI();
            
            // AI å›åˆ
            if (gameMode === 'ai' && currentPlayer === 2 && !gameOver) {
                setTimeout(aiTurn, 1000);
            }
        }

        function endGame(winner) {
            gameOver = true;
            const overlay = document.getElementById('overlay');
            const winnerName = gameMode === 'ai' && winner === 2 ? 'AI' : `ç©å®¶ ${winner}`;
            overlay.innerHTML = `
                <h1>ğŸ† éŠæˆ²çµæŸ</h1>
                <h2 class="winner-text">${winnerName} ç²å‹ï¼</h2>
                <p style="color: #fff; font-size: 20px; margin-bottom: 20px;">
                    ç©å®¶1: ${scores[0]} åˆ† | ${gameMode === 'ai' ? 'AI' : 'ç©å®¶2'}: ${scores[1]} åˆ†
                </p>
                <button class="menu-btn" onclick="returnToMainMenu()">ğŸ”„ è¿”å›ä¸»é¸å–®</button>
            `;
            overlay.classList.remove('hidden');
        }

        // ========== AI ç³»çµ± ==========
        function aiTurn() {
            if (!striker || isMoving || gameOver) return;
            
            // æ‰¾æœ€ä½³ç›®æ¨™
            const targets = pieces.filter(p => !p.pocketed && p.type === 'black');
            if (targets.length === 0) return;
            
            let bestTarget = null;
            let bestScore = -Infinity;
            
            targets.forEach(target => {
                currentPockets.forEach(pocket => {
                    const score = evaluateShot(striker, target, pocket);
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = { piece: target, pocket };
                    }
                });
            });
            
            if (bestTarget) {
                // è¨ˆç®—å°„æ“Šè§’åº¦
                const dx = bestTarget.piece.x - striker.x;
                const dy = bestTarget.piece.y - striker.y;
                const angle = Math.atan2(dy, dx);
                const powerMod = getPowerModifier();
                const basePower = Math.min(0.5 + Math.random() * 0.4, 1);
                const force = basePower * CONFIG.maxPower * Math.min(powerMod, 3);
                
                striker.vx = Math.cos(angle) * force;
                striker.vy = Math.sin(angle) * force;
                
                // å¦‚æœæœ‰ç¬¬äºŒå€‹æ“Šçƒå™¨ï¼ŒåŒæ™‚ç™¼å°„
                if (striker2) {
                    striker2.vx = Math.cos(angle) * force;
                    striker2.vy = Math.sin(angle) * force;
                }
                
                // é‡ç½®é€™å›åˆçš„å…¥è¢‹è¿½è¹¤
                pocketedThisTurn = { white: 0, black: 0, queen: false, striker: false };
                
                isMoving = true;
                playSound('hit');
            }
        }

        function evaluateShot(striker, target, pocket) {
            const d1 = Math.hypot(target.x - striker.x, target.y - striker.y);
            const d2 = Math.hypot(pocket.x - target.x, pocket.y - target.y);
            
            // è¨ˆç®—è§’åº¦å°é½Š
            const angle1 = Math.atan2(target.y - striker.y, target.x - striker.x);
            const angle2 = Math.atan2(pocket.y - target.y, pocket.x - target.x);
            const angleDiff = Math.abs(angle1 - angle2);
            
            return 100 - d1 * 0.1 - d2 * 0.1 - angleDiff * 20;
        }

        // ========== æ¸²æŸ“ç³»çµ± ==========
        function render() {
            ctx.clearRect(0, 0, boardSize, boardSize);
            
            drawBoard();
            drawPieces();
            drawStriker();
            drawAimLine();
        }

        function drawBoard() {
            // å¤–æ¡†æœ¨ç´‹
            const woodGrad = ctx.createLinearGradient(0, 0, boardSize, boardSize);
            woodGrad.addColorStop(0, '#8B4513');
            woodGrad.addColorStop(0.3, '#A0522D');
            woodGrad.addColorStop(0.6, '#8B4513');
            woodGrad.addColorStop(1, '#654321');
            ctx.fillStyle = woodGrad;
            ctx.fillRect(0, 0, boardSize, boardSize);
            
            // å…§éƒ¨éŠæˆ²å€
            ctx.fillStyle = '#d4b896';
            ctx.fillRect(innerX, innerY, innerSize, innerSize);
            
            // è£é£¾ç·š
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.strokeRect(innerX + 10, innerY + 10, innerSize - 20, innerSize - 20);
            
            // ä¸­å¿ƒåœ“
            const center = boardSize / 2;
            ctx.beginPath();
            ctx.arc(center, center, innerSize * 0.12, 0, Math.PI * 2);
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(center, center, innerSize * 0.06, 0, Math.PI * 2);
            ctx.stroke();
            
            // è§’è½ç®­é ­å€åŸŸ
            const arrowDist = innerSize * 0.15;
            [[1,1], [1,-1], [-1,1], [-1,-1]].forEach(([dx, dy]) => {
                ctx.beginPath();
                ctx.arc(center + dx * arrowDist, center + dy * arrowDist, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#8B4513';
                ctx.fill();
            });
            
            // åŸºç·š
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.5)';
            ctx.lineWidth = 2;
            
            // ç©å®¶1åŸºç·šï¼ˆä¸‹ï¼‰
            const baseline1Y = innerY + innerSize - innerSize * 0.22;
            ctx.beginPath();
            ctx.moveTo(innerX + innerSize * 0.15, baseline1Y);
            ctx.lineTo(innerX + innerSize * 0.85, baseline1Y);
            ctx.stroke();
            
            // ç©å®¶2åŸºç·šï¼ˆä¸Šï¼‰
            const baseline2Y = innerY + innerSize * 0.22;
            ctx.beginPath();
            ctx.moveTo(innerX + innerSize * 0.15, baseline2Y);
            ctx.lineTo(innerX + innerSize * 0.85, baseline2Y);
            ctx.stroke();
            
            // å¦‚æœå°æ‰‹æœ‰èº«ä¸ç”±å·±å¤©è³¦ï¼Œé¡¯ç¤ºé›™æ“Šçƒå™¨æ¨™è¨˜
            if (hasDualStrikers && !isMoving && !gameOver) {
                const lockY = currentPlayer === 1 ? baseline1Y : baseline2Y;
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.fillRect(innerX + innerSize * 0.15, lockY - 20, innerSize * 0.7, 40);
                ctx.fillStyle = '#ff6600';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ”’ é›™æ“Šçƒå™¨æ¨¡å¼ - å·¦å³åŒæ™‚ç™¼å°„', boardSize / 2, lockY + 5);
            }
            
            // ç¹ªè£½è¢‹å£
            currentPockets.forEach(pocket => {
                // é™°å½±
                ctx.beginPath();
                ctx.arc(pocket.x + 2, pocket.y + 2, pocket.size, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                // è¢‹å£
                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, pocket.size, 0, Math.PI * 2);
                if (pocket.isCenter) {
                    ctx.fillStyle = '#3a1a3a'; // ä¸­å¿ƒæ´ç”¨ç´«è‰²
                } else if (pocket.extra) {
                    ctx.fillStyle = '#2a1a0a';
                } else {
                    ctx.fillStyle = '#1a1a1a';
                }
                ctx.fill();
                
                // å…§ç’°
                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, pocket.size - 4, 0, Math.PI * 2);
                if (pocket.isCenter) {
                    ctx.strokeStyle = '#6a3a6a';
                } else if (pocket.extra) {
                    ctx.strokeStyle = '#4a3a2a';
                } else {
                    ctx.strokeStyle = '#333';
                }
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // é¡å¤–æ´çš„æ¨™è¨˜
                if (pocket.extra) {
                    ctx.beginPath();
                    ctx.arc(pocket.x, pocket.y, pocket.size * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffd700';
                    ctx.fill();
                }
                
                // ä¸­å¿ƒæ´çš„æ¨™è¨˜
                if (pocket.isCenter) {
                    ctx.beginPath();
                    ctx.arc(pocket.x, pocket.y, pocket.size * 0.2, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff00ff';
                    ctx.fill();
                }
            });
        }

        function drawPieces() {
            pieces.forEach(piece => {
                if (piece.pocketed) return;
                
                // é™°å½±
                ctx.beginPath();
                ctx.arc(piece.x + 3, piece.y + 3, piece.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                
                // ç›¤å­
                ctx.beginPath();
                ctx.arc(piece.x, piece.y, piece.radius, 0, Math.PI * 2);
                
                const grad = ctx.createRadialGradient(
                    piece.x - piece.radius * 0.3, 
                    piece.y - piece.radius * 0.3, 
                    0,
                    piece.x, piece.y, piece.radius
                );
                
                if (piece.type === 'white') {
                    grad.addColorStop(0, '#fffef0');
                    grad.addColorStop(1, '#d4d4aa');
                } else if (piece.type === 'black') {
                    grad.addColorStop(0, '#4a4a4a');
                    grad.addColorStop(1, '#1a1a1a');
                } else {
                    grad.addColorStop(0, '#ef4444');
                    grad.addColorStop(1, '#991b1b');
                }
                
                ctx.fillStyle = grad;
                ctx.fill();
                
                ctx.strokeStyle = piece.type === 'black' ? '#000' : '#888';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // å…§åœˆè£é£¾
                ctx.beginPath();
                ctx.arc(piece.x, piece.y, piece.radius * 0.6, 0, Math.PI * 2);
                ctx.strokeStyle = piece.type === 'queen' ? '#fbbf24' : 
                                 piece.type === 'white' ? '#ccc' : '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        function drawStriker() {
            // ç¹ªè£½ä¸»æ“Šçƒå™¨
            if (striker && !striker.pocketed) {
                drawSingleStriker(striker, '#fde047', '#ca8a04');
            }
            
            // ç¹ªè£½ç¬¬äºŒå€‹æ“Šçƒå™¨ï¼ˆå¦‚æœæœ‰ï¼‰
            if (striker2 && !striker2.pocketed) {
                drawSingleStriker(striker2, '#fdba74', '#ea580c');
            }
        }
        
        function drawSingleStriker(s, colorLight, colorDark) {
            // é™°å½±
            ctx.beginPath();
            ctx.arc(s.x + 3, s.y + 3, s.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();
            
            // æ“Šçƒå™¨
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
            
            const grad = ctx.createRadialGradient(
                s.x - s.radius * 0.3,
                s.y - s.radius * 0.3,
                0,
                s.x, s.y, s.radius
            );
            grad.addColorStop(0, colorLight);
            grad.addColorStop(1, colorDark);
            
            ctx.fillStyle = grad;
            ctx.fill();
            
            ctx.strokeStyle = '#92400e';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ä¸­å¿ƒé»
            ctx.beginPath();
            ctx.arc(s.x, s.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#92400e';
            ctx.fill();
        }

        function drawAimLine() {
            if (!isAiming || !striker) return;
            
            const dx = dragStart.x - aimEnd.x;
            const dy = dragStart.y - aimEnd.y;
            const angle = Math.atan2(dy, dx);
            const aimMod = getAimLengthModifier();
            const baseLength = Math.min(Math.hypot(dx, dy) * 2, CONFIG.baseAimLength);
            const length = baseLength * aimMod;
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ä¸€è§¸å³ç™¼å¤©è³¦ï¼ˆå¯ä»¥é¡¯ç¤ºåå½ˆè·¯å¾‘ï¼‰
            const myTalent = playerTalents[currentPlayer - 1];
            const showBounce = myTalent === 'precision';
            
            if (showBounce) {
                // ç¹ªè£½å¸¶åå½ˆçš„ç„æº–ç·š
                drawBouncingAimLine(striker, angle, length);
                if (striker2) {
                    drawBouncingAimLine(striker2, angle, length);
                }
            } else {
                // æ™®é€šç„æº–ç·š
                drawSimpleAimLine(striker, angle, length);
                if (striker2) {
                    drawSimpleAimLine(striker2, angle, length);
                }
            }
            
            // åŠ›é‡æ¢
            const barWidth = 100;
            const barHeight = 12;
            const barX = striker.x - barWidth / 2;
            const barY = striker.y + striker.radius + 20;
            
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            const powerMod = getPowerModifier();
            const displayPower = Math.min(power * powerMod, 1);
            
            const powerGrad = ctx.createLinearGradient(barX, 0, barX + barWidth, 0);
            powerGrad.addColorStop(0, '#22c55e');
            powerGrad.addColorStop(0.5, '#eab308');
            powerGrad.addColorStop(1, '#ef4444');
            
            ctx.fillStyle = powerGrad;
            ctx.fillRect(barX, barY, barWidth * displayPower, barHeight);
            
            // é¡¯ç¤ºåŠ›é‡ä¿®æ­£
            if (powerMod !== 1) {
                ctx.fillStyle = powerMod > 1 ? '#4ade80' : '#ef4444';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const modText = powerMod > 1 ? `ç„æº–ç·š x${aimMod.toFixed(1)}` : `åŠ›é‡ x${powerMod.toFixed(1)}`;
                ctx.fillText(modText, striker.x, barY + barHeight + 15);
            }
        }

        function drawSimpleAimLine(s, angle, length) {
            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(
                s.x + Math.cos(angle) * length,
                s.y + Math.sin(angle) * length
            );
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 + power * 0.5})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // åŠ›é‡æŒ‡ç¤ºé»
            const dotCount = 5;
            for (let i = 0; i < dotCount; i++) {
                const dotDist = (i + 1) * length / (dotCount + 1);
                const dotX = s.x + Math.cos(angle) * dotDist;
                const dotY = s.y + Math.sin(angle) * dotDist;
                
                ctx.beginPath();
                ctx.arc(dotX, dotY, 4 - i * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, ${255 - power * 200}, 0, ${1 - i * 0.1})`;
                ctx.fill();
            }
        }

        function drawBouncingAimLine(s, angle, totalLength) {
            let currentX = s.x;
            let currentY = s.y;
            let currentAngle = angle;
            let remainingLength = totalLength;
            let bounceCount = 0;
            const maxBounces = 5;
            
            ctx.beginPath();
            ctx.moveTo(currentX, currentY);
            
            while (remainingLength > 0 && bounceCount < maxBounces) {
                // è¨ˆç®—ä¸‹ä¸€å€‹ä½ç½®
                let nextX = currentX + Math.cos(currentAngle) * remainingLength;
                let nextY = currentY + Math.sin(currentAngle) * remainingLength;
                
                // æª¢æŸ¥æ˜¯å¦ç¢°åˆ°é‚Šç•Œ
                const minX = innerX + CONFIG.strikerRadius;
                const maxX = innerX + innerSize - CONFIG.strikerRadius;
                const minY = innerY + CONFIG.strikerRadius;
                const maxY = innerY + innerSize - CONFIG.strikerRadius;
                
                let hitWall = false;
                let hitX = nextX;
                let hitY = nextY;
                let travelDist = remainingLength;
                
                // æª¢æŸ¥å·¦å³é‚Šç•Œ
                if (nextX < minX || nextX > maxX) {
                    const wallX = nextX < minX ? minX : maxX;
                    const t = (wallX - currentX) / (nextX - currentX);
                    hitX = wallX;
                    hitY = currentY + t * (nextY - currentY);
                    travelDist = Math.hypot(hitX - currentX, hitY - currentY);
                    hitWall = true;
                    currentAngle = Math.PI - currentAngle; // æ°´å¹³åå½ˆ
                }
                
                // æª¢æŸ¥ä¸Šä¸‹é‚Šç•Œ
                if (nextY < minY || nextY > maxY) {
                    const wallY = nextY < minY ? minY : maxY;
                    const t = (wallY - currentY) / (nextY - currentY);
                    const testHitX = currentX + t * (nextX - currentX);
                    const testHitY = wallY;
                    const testDist = Math.hypot(testHitX - currentX, testHitY - currentY);
                    
                    if (testDist < travelDist) {
                        hitX = testHitX;
                        hitY = testHitY;
                        travelDist = testDist;
                        hitWall = true;
                        currentAngle = -currentAngle; // å‚ç›´åå½ˆ
                    }
                }
                
                ctx.lineTo(hitX, hitY);
                
                if (hitWall) {
                    bounceCount++;
                    remainingLength -= travelDist;
                    currentX = hitX;
                    currentY = hitY;
                    
                    // ç¹ªè£½åå½ˆé»
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(hitX, hitY, 6, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 200, 0, ${0.8 - bounceCount * 0.15})`;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(currentX, currentY);
                } else {
                    remainingLength = 0;
                }
            }
            
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.4 + power * 0.4})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 8]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // é è¦½ç¢°æ’ç›¤å­
            simulateCollisions(s, angle, totalLength);
        }

        function simulateCollisions(s, angle, totalLength) {
            // æ¨¡æ“¬æ“Šçƒå™¨è·¯å¾‘ï¼Œé è¦½å¯èƒ½ç¢°åˆ°çš„ç›¤å­
            let currentX = s.x;
            let currentY = s.y;
            let currentAngle = angle;
            let remainingLength = totalLength;
            let bounceCount = 0;
            const maxBounces = 5;
            const stepSize = 5;
            
            const hitPieces = new Set();
            
            while (remainingLength > 0 && bounceCount < maxBounces) {
                const step = Math.min(stepSize, remainingLength);
                const nextX = currentX + Math.cos(currentAngle) * step;
                const nextY = currentY + Math.sin(currentAngle) * step;
                
                // æª¢æŸ¥æ˜¯å¦ç¢°åˆ°ç›¤å­
                pieces.forEach(piece => {
                    if (piece.pocketed || hitPieces.has(piece)) return;
                    const dist = Math.hypot(nextX - piece.x, nextY - piece.y);
                    if (dist < CONFIG.strikerRadius + piece.radius) {
                        hitPieces.add(piece);
                        
                        // ç¹ªè£½ç¢°æ’é è¦½
                        ctx.beginPath();
                        ctx.arc(piece.x, piece.y, piece.radius + 5, 0, Math.PI * 2);
                        ctx.strokeStyle = piece.type === 'queen' ? '#ff0000' : 
                                         piece.type === 'white' ? '#00ff00' : '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // é æ¸¬ç›¤å­çš„é£›è¡Œæ–¹å‘
                        const hitAngle = Math.atan2(piece.y - nextY, piece.x - nextX);
                        const predictLength = 80;
                        ctx.beginPath();
                        ctx.moveTo(piece.x, piece.y);
                        ctx.lineTo(
                            piece.x + Math.cos(hitAngle) * predictLength,
                            piece.y + Math.sin(hitAngle) * predictLength
                        );
                        ctx.strokeStyle = `rgba(255, 255, 0, 0.5)`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                });
                
                // æª¢æŸ¥é‚Šç•Œ
                const minX = innerX + CONFIG.strikerRadius;
                const maxX = innerX + innerSize - CONFIG.strikerRadius;
                const minY = innerY + CONFIG.strikerRadius;
                const maxY = innerY + innerSize - CONFIG.strikerRadius;
                
                if (nextX < minX || nextX > maxX) {
                    currentAngle = Math.PI - currentAngle;
                    bounceCount++;
                }
                if (nextY < minY || nextY > maxY) {
                    currentAngle = -currentAngle;
                    bounceCount++;
                }
                
                currentX = Math.max(minX, Math.min(maxX, nextX));
                currentY = Math.max(minY, Math.min(maxY, nextY));
                remainingLength -= step;
            }
        }

        function updateUI() {
            document.getElementById('score1').textContent = scores[0];
            document.getElementById('score2').textContent = scores[1];
            
            document.getElementById('player1Info').classList.toggle('active', currentPlayer === 1);
            document.getElementById('player2Info').classList.toggle('active', currentPlayer === 2);
            
            let turnText;
            if (gameMode === 'ai' && currentPlayer === 2) {
                turnText = 'AI æ€è€ƒä¸­...';
            } else {
                turnText = `ç©å®¶${currentPlayer} çš„å›åˆ`;
                if (hasDualStrikers) {
                    turnText += ' (é›™æ“Šçƒå™¨)';
                }
            }
            document.getElementById('turnIndicator').textContent = turnText;
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.classList.add('show');
            setTimeout(() => msg.classList.remove('show'), 2500);
        }

        // ========== éŠæˆ²å¾ªç’° ==========
        function gameLoop() {
            updatePhysics();
            render();
            requestAnimationFrame(gameLoop);
        }

        // å•Ÿå‹•
        init();
    </script>
</body>
</html>