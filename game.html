<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>å¡”é˜²ç‹åœ‹ï¼(å„ªåŒ–ç‰ˆ)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
  /* --- å…¨å±€æ¨£å¼ --- */
  body, html { 
    margin:0; padding:0; overflow:hidden; background:#333; 
    font-family:Arial, sans-serif; touch-action:manipulation;
    user-select:none;
    height: 100%; 
    height: -webkit-fill-available;
  }
  
  /* --- ä¸»é¸å–®å®¹å™¨ --- */
  #mainMenu {
    position:relative;
    width:100vw;
    height: 100%;
    height: -webkit-fill-available;
    box-sizing: border-box;
    display:flex; 
    flex-direction:column;
    justify-content:center;
    align-items:center;
    background:linear-gradient(145deg, #1a1a2e, #16213e);
    color:white;
  }
  
  /* --- éŠæˆ²å®¹å™¨ (é è¨­éš±è—) --- */
  #game { 
    position:relative; width:100vw; height:100vh; 
    display:none; 
    justify-content:center; align-items:center;
    background:#5c94fc;
  }

  /* --- ä»‹é¢åˆ‡æ›å®¹å™¨ --- */
  #screenContainer {
    flex-grow:1;
    width:100%;
    max-width:450px;
    position:relative;
    overflow:hidden;
  }
  
  /* --- ä¸‰å€‹ä¸»ä»‹é¢ --- */
  .screen {
    position:absolute;
    top:0; left:0; width:100%; height:100%;
    padding:20px;
    box-sizing:border-box;
    display:none;
    flex-direction:column;
    align-items:center;
    overflow-y:auto;
  }
  #homeScreen { display:flex; justify-content:center; }
  #deckScreen { display:none; }
  #tacticsScreen { display:none; }

  /* --- åº•éƒ¨å°èˆª --- */
  #bottomNav {
    width:100%;
    max-width:450px;
    display:flex;
    justify-content:space-around;
    background:rgba(0,0,0,0.3);
    padding: 10px 0;
    padding-bottom: max(15px, env(safe-area-inset-bottom));
    box-shadow:0 -5px 15px rgba(0,0,0,0.3);
  }
  .navBtn {
    font-size:34px;
    padding:8px 20px;
    border-radius:15px;
    cursor:pointer;
    transition:all 0.2s;
    background:transparent;
    border:3px solid transparent;
  }
  .navBtn.active {
    background:rgba(255,255,255,0.15);
    border-color: #ff6b35;
  }
  .navBtn:active {
    transform:scale(0.9);
  }

  /* --- ä¸»é  (Home) --- */
  #startGameBtn {
    font-size:28px;
    font-weight:bold;
    color:white;
    background:linear-gradient(145deg, #4CAF50, #45a049);
    border:none;
    padding:25px 50px;
    border-radius:20px;
    box-shadow:0 8px 25px rgba(0,0,0,0.5);
    cursor:pointer;
    transition:all 0.2s;
  }
  #startGameBtn:active {
    transform:scale(0.95);
  }

  /* --- å¡ç‰Œ (Deck) --- */
  .deck-title {
    font-size:22px;
    font-weight:bold;
    margin-bottom:15px;
    text-shadow:0 0 5px #fff;
  }
  .deck-container {
    display:grid;
    grid-template-columns:repeat(4, 1fr);
    gap:10px;
    width:100%;
    background:rgba(0,0,0,0.2);
    padding:15px;
    border-radius:15px;
    margin-bottom:20px;
  }
  
  .deck-slot, .deck-card {
    aspect-ratio:0.75;
    border-radius:10px;
    box-sizing:border-box;
    transition:all 0.2s;
  }

  .deck-card {
    background:linear-gradient(145deg, #444, #222);
    border:3px solid #777;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:space-between;
    padding:8px 5px;
    cursor:grab;
  }
  
  .deck-slot {
    background:rgba(0,0,0,0.3);
    border:3px dashed #888;
    cursor:default;
    display:flex; 
    padding: 0;
  }

  .deck-slot > .deck-card {
    width: 100%;
    height: 100%;
    cursor: default;
  }

  .deck-slot.drag-over {
    background:rgba(255,255,255,0.2);
    border-color:#fff;
  }

  .deck-card:active {
    cursor:grabbing;
    transform:scale(1.05);
    border-color:#ffc107;
  }
  
  .card-power {
    position:relative;
    background:linear-gradient(145deg, #4169E1, #2a48a3);
    border:2px solid #fff;
    border-radius:50%;
    width:30px;
    height:30px;
    display:flex;
    justify-content:center;
    align-items:center;
    font-size:16px;
    font-weight:bold;
    color:white;
    box-shadow:0 0 8px rgba(0,0,0,0.7);
    margin-bottom:5px;
  }
  .card-power.life {
    background:linear-gradient(145deg, #FF69B4, #d64f90);
    font-size: 12px; 
  }
  .card-power.encourage {
    background:linear-gradient(145deg, #FFB6C1, #e0a0b0);
  }
  .card-power.gold {
    background:linear-gradient(145deg, #FFD700, #DAA520);
    color: #000;
    font-size: 12px;
  }

  .card-emoji {
    font-size:28px;
    flex-grow:1;
    display:flex;
    justify-content:center;
    align-items:center;
  }
  .card-name {
    font-size:12px;
    font-weight:bold;
    text-align:center;
    width:100%;
  }

  /* --- æˆ°è¡“ (Tactics) --- */
  #tacticsScreen h2 {
    font-size:22px;
    margin-bottom:20px;
  }
  .tactic-card {
    width:100%;
    background:linear-gradient(145deg, #333, #555);
    border:3px solid #888;
    border-radius:15px;
    padding:18px;
    margin-bottom:15px;
    box-sizing:border-box;
    cursor:pointer;
    transition:all 0.2s;
  }
  .tactic-card:hover {
    transform:translateY(-3px);
  }
  .tactic-card.selected {
    background:linear-gradient(145deg, #ff6b35, #f7931e);
    border-color:#fff;
    box-shadow:0 0 15px #f7931e;
  }
  .tactic-card h3 {
    margin:0 0 8px 0;
    font-size:18px;
  }
  .tactic-card p {
    margin:0;
    font-size:14px;
    color:#ddd;
  }
  
  /* --- é¸å–®è¨Šæ¯ --- */
  #menuMessage {
    position:absolute;
    bottom:100px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(255,0,0,0.8);
    color:white;
    padding:15px 25px;
    border-radius:10px;
    z-index:200;
    display:none;
    font-weight:bold;
  }

  /* --- éŠæˆ²ç•«é¢æ¨£å¼ --- */
  #canvasContainer {
    width:90vmin; 
    aspect-ratio:9/16;
    max-width:414px; max-height:736px;
    position:relative; background:rgba(0,0,0,0.15);
    border-radius:18px; box-shadow:0 0 40px rgba(0,0,0,0.6);
    overflow:hidden;
  }
  canvas { 
    display:block; width:100%; height:100%; 
    border-radius:18px; touch-action:none;
  }
  #ui {
    position:absolute; top:15px; left:15px; color:white; font-weight:bold;
    text-shadow:0 0 6px black; font-size:18px; z-index:10;
  }
  #speedBtn {
    position:absolute; 
    top: 85px; 
    right: 15px;
    width:60px; height:60px; background:linear-gradient(145deg, #ff4444, #cc3333);
    border:none; border-radius:50%; color:white; font-size:20px; font-weight:bold;
    box-shadow:0 6px 18px rgba(0,0,0,0.5); cursor:pointer;
    touch-action:manipulation; z-index:20;
  }
  #speedBtn:active { transform:scale(0.93); }

  #settingsBtn {
    position:absolute; top: 15px; right: 15px;
    width:60px; height:60px; background:linear-gradient(145deg, #888, #666);
    border:none; border-radius:50%; color:white; font-size:30px; font-weight:bold;
    box-shadow:0 6px 18px rgba(0,0,0,0.5); cursor:pointer;
    touch-action:manipulation; z-index:20;
  }
  #settingsBtn:active { transform:scale(0.93); }

  #bottomControls {
    position:absolute;
    left:0; right:0;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:22px;
    z-index:25;
    pointer-events:none;
  }
  #skillBtn, #placeBtn, #castleBtn {
    pointer-events:auto;
    width:68px; height:68px; border:none; border-radius:50%;
    color:white; font-size:14px; font-weight:bold;
    box-shadow:0 8px 20px rgba(0,0,0,0.5); cursor:pointer;
    touch-action:manipulation; transition:all 0.2s;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    padding:6px; line-height:1.1;
  }
  #skillBtn { background:linear-gradient(145deg, #4CAF50, #45a049); }
  #castleBtn { background:linear-gradient(145deg, #DAA520, #B8860B); font-size:34px; }
  #placeBtn { background:linear-gradient(145deg, #ff6b35, #f7931e); }
  #skillBtn:active, #castleBtn:active, #placeBtn:active { transform:scale(0.93); box-shadow:0 4px 15px rgba(0,0,0,0.5); }

  .costBubble {
    position:absolute;
    background:rgba(0,0,0,0.6);
    color:#fff;
    font-size:12px;
    padding:4px 8px;
    border-radius:10px;
    text-shadow:0 0 3px #000;
    z-index:30;
    pointer-events:none;
  }

  #skillModal, #castleModal, #towerInfoModal, #settingsModal {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    background:linear-gradient(145deg, #1a1a2e, #16213e); 
    color:#fff; padding:35px; border-radius:25px; border:4px solid #ff6b35;
    text-align:center; display:none; max-width:92vw; max-height:75vh;
    overflow-y:auto; box-shadow:0 20px 60px rgba(0,0,0,0.95); z-index:100;
  }
  #castleModal { border-color:#DAA520; }
  #towerInfoModal { border-color:#00FF00; }
  #settingsModal { border-color:#aaa; }

  #skillTitle, #castleTitle, #towerInfoTitle {
    margin:0 0 25px 0; font-size:22px; text-shadow:0 0 6px #ff6b35;
  }
  #castleTitle { text-shadow:0 0 6px #DAA520; }
  #towerInfoTitle { text-shadow:0 0 6px #00FF00; }

  #skillOptions, #castleOptions {
    display:flex; justify-content:center; gap:18px; margin:30px 0;
    flex-wrap:wrap;
  }
  .skillOpt, .castleOpt {
    flex:1; min-width:110px; max-width:150px; padding:20px 15px; 
    background:linear-gradient(145deg, #333, #555); border:3px solid #888;
    border-radius:18px; cursor:pointer; font-size:16px; transition:all 0.3s;
    box-shadow:0 5px 15px rgba(0,0,0,0.4);
  }
  .skillOpt:hover, .castleOpt:hover { 
    background:linear-gradient(145deg, #555, #777); 
    border-color:#ffcc00; transform:translateY(-4px); box-shadow:0 10px 25px rgba(0,0,0,0.6);
  }

  #towerInfoContent {
    text-align:left; background:rgba(0,0,0,0.3); padding:20px; border-radius:15px; margin:20px 0;
  }
  #towerInfoContent p {
    margin:10px 0; font-size:16px; line-height:1.8;
  }
  #towerInfoContent strong {
    color:#00FF00;
  }
  #towerInfoContent.life-tower strong { color: #FF69B4; }
  #towerInfoTitle.life-tower { text-shadow: 0 0 6px #FF69B4; }
  #towerInfoModal.life-tower { border-color: #FF69B4; }

  #towerInfoContent.encourage-tower strong { color: #FFB6C1; }
  #towerInfoTitle.encourage-tower { text-shadow: 0 0 6px #FFB6C1; }
  #towerInfoModal.encourage-tower { border-color: #FFB6C1; }
  
  #towerInfoContent.gold-tower strong { color: #FFD700; }
  #towerInfoTitle.gold-tower { text-shadow: 0 0 6px #FFD700; }
  #towerInfoModal.gold-tower { border-color: #FFD700; }
  
  #towerInfoContent.win-tower strong { color: #C0C0C0; }
  #towerInfoTitle.win-tower { text-shadow: 0 0 6px #C0C0C0; }
  #towerInfoModal.win-tower { border-color: #C0C0C0; }

  #settingsModal h3 {
    margin:0 0 20px 0; font-size:22px; color:white;
  }
  #settingsModal p {
    font-size: 16px; margin-bottom: 25px;
  }
  .settingsOptions {
    display:flex; justify-content:center; gap:20px;
  }

  #info {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    background:linear-gradient(145deg, #1a1a2e, #16213e); color:#fff; 
    padding:45px; border-radius:25px; border:4px solid #ff4444;
    text-align:center; display:none; max-width:88vw; z-index:100;
  }
  #info.victory { border-color:#FFD700; }
  #info button, #skillModal button, #castleModal button, #towerInfoModal button, #settingsModal button { 
    background:linear-gradient(145deg, #4CAF50, #45a049); 
    color:white; border:none; padding:18px 35px; border-radius:15px; 
    font-size:20px; margin-top:25px; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,0.4);
  }

  #settingsModal button {
    margin-top:0;
    padding:15px 30px;
    font-size:18px;
  }
  #confirmExitBtn { background:linear-gradient(145deg, #ff4444, #cc3333); }
  #cancelExitBtn { background:linear-gradient(145deg, #777, #555); }
</style>
</head>
<body>

<!-- --- ä¸»é¸å–® --- -->
<div id="mainMenu">
  <div id="screenContainer">
    
    <!-- å¡ç‰Œä»‹é¢ (å·¦) -->
    <div id="deckScreen" class="screen">
      <div class="deck-title">å‡ºæˆ°ç‰Œçµ„ (æ‹–æ”¾ 4 å€‹)</div>
      <div id="battleDeck" class="deck-container">
        <div class="deck-slot" data-slot="0"></div>
        <div class="deck-slot" data-slot="1"></div>
        <div class="deck-slot" data-slot="2"></div>
        <div class="deck-slot" data-slot="3"></div>
      </div>

      <div class="deck-title">å¯ç”¨å¡” (æ‹–æ›³ä¸Šæ–¹)</div>
      <div id="availableTowers" class="deck-container"></div>
    </div>
    
    <!-- ä¸»ä»‹é¢ (ä¸­) -->
    <div id="homeScreen" class="screen">
      <button id="startGameBtn">âš”ï¸ é–‹å§‹æˆ°é¬¥ âš”ï¸</button>
    </div>
    
    <!-- æˆ°è¡“ä»‹é¢ (å³) -->
    <div id="tacticsScreen" class="screen">
      <h2>é¸æ“‡æˆ°è¡“ (1 ç¨®)</h2>
      <div id="tacticList"></div>
    </div>

  </div>
  
  <div id="menuMessage"></div>

  <div id="bottomNav">
    <button class="navBtn" data-screen="deckScreen">ğŸ§©</button>
    <button class="navBtn active" data-screen="homeScreen">âš”ï¸</button>
    <button class="navBtn" data-screen="tacticsScreen">ğŸ§ </button>
  </div>
</div>

<!-- --- éŠæˆ²ç•«é¢ --- -->
<div id="game">
  <div id="canvasContainer">
    <canvas id="canvas"></canvas>
    <div id="ui">
      <div>é‡‘å¹£: $<span id="gold">5001</span></div>
      <div>åœ‹ç‹è¡€é‡: <span id="hp">30/30</span></div>
      <div>æ³¢æ¬¡: <span id="wave">1</span></div>
    </div>
    <button id="settingsBtn" onclick="openSettings()">âš™ï¸</button>
    <button id="speedBtn" onclick="toggleSpeed()">1x</button>

    <div id="bottomControls">
      <button id="skillBtn" onclick="openSkill()">æŠ€èƒ½</button>
      <button id="castleBtn" onclick="openCastle()">ğŸ°</button>
      <button id="placeBtn" onclick="placeTower()">æ”¾ç½®</button>
    </div>

    <div id="skillCostBubble" class="costBubble">$500</div>
    <div id="placeCostBubble" class="costBubble">$1</div>
    <div id="castleCostBubble" class="costBubble">$2000</div>

    <div id="skillModal">
      <h3 id="skillTitle">æŠ€èƒ½é¸æ“‡</h3>
      <div id="skillOptions"></div>
      <button onclick="closeSkill()">å–æ¶ˆ</button>
    </div>

    <div id="castleModal">
      <h3 id="castleTitle">åŸå ¡æŠ€èƒ½</h3>
      <div id="castleOptions"></div>
      <button onclick="closeCastle()">å–æ¶ˆ</button>
    </div>

    <div id="towerInfoModal">
      <h3 id="towerInfoTitle">å¡”è©³ç´°è³‡è¨Š</h3>
      <div id="towerInfoContent"></div>
      <button onclick="closeTowerInfo()">é—œé–‰</button>
    </div>

    <div id="settingsModal">
      <h3>é€€å‡ºæˆ°é¬¥ï¼Ÿ</h3>
      <p>æ‚¨ç¢ºå®šè¦é€€å‡ºç•¶å‰æˆ°é¬¥ä¸¦è¿”å›ä¸»é¸å–®å—ï¼Ÿ</p>
      <div class="settingsOptions">
        <button id="confirmExitBtn" onclick="resetGame()">æ˜¯ï¼Œé€€å‡º</button>
        <button id="cancelExitBtn" onclick="closeSettings()">å¦ï¼Œç¹¼çºŒ</button>
      </div>
    </div>

    <div id="info">
      <h2 id="infoTitle"></h2>
      <p id="infoText"></p>
      <button onclick="closeInfo()">è¿”å›ä¸»é¸å–®</button>
    </div>
  </div>
</div>

<script>
/* ==============================================
 * éŠæˆ²æ ¸å¿ƒé‚è¼¯
 * ============================================== */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvasContainer');
const ui = { wave: document.getElementById('wave'), gold: document.getElementById('gold'), hp: document.getElementById('hp') };
const skillModal = document.getElementById('skillModal');
const castleModal = document.getElementById('castleModal');
const towerInfoModal = document.getElementById('towerInfoModal');
const settingsModal = document.getElementById('settingsModal');
const speedBtn = document.getElementById('speedBtn');
const infoModal = document.getElementById('info');
const bottomControls = document.getElementById('bottomControls');
const skillBtn = document.getElementById('skillBtn');
const placeBtn = document.getElementById('placeBtn');
const castleBtn = document.getElementById('castleBtn');
const skillCostBubble = document.getElementById('skillCostBubble');
const placeCostBubble = document.getElementById('placeCostBubble');
const castleCostBubble = document.getElementById('castleCostBubble');

// --- éŠæˆ²è¿´åœˆæ§åˆ¶ ---
let gameLoopId = null; 

// --- éŸ³æ•ˆè¨­å®š ---
let synth = null;
let audioInitialized = false;

async function initAudio() {
    if (audioInitialized) return;
    try {
        await Tone.start();
        synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.005, decay: 0.08, sustain: 0.01, release: 0.1 }
        }).toDestination();
        audioInitialized = true;
    } catch (e) { console.error(e); }
}
function playShotSound() {
    if (synth && audioInitialized) {
        const pitches = ['C5', 'D5', 'E5'];
        synth.triggerAttackRelease(pitches[Math.floor(Math.random() * pitches.length)], "16n");
    }
}
function playHealSound() {
    if (synth && audioInitialized) synth.triggerAttackRelease("G5", "8n");
}

// --- éŠæˆ²è¨­å®š ---
let TILE;
let cols, rows, gameWidth, gameHeight;
const BASELINE_Y = 0.82;
let gameSpeed = 1;
let castleY;
let maxHp = 30;
let gameTime = 0; 
let lastRealTime = 0; 

let nextBossStunTime = 0;
let towersStunnedUntil = 0;
const bossStunInterval = 10000;
const bossStunDuration = 2000;

let slots = [];
let mouse = { x: 0, y: 0 };
let potentialDrag = null;
let draggingTower = null;
let dragging = false;
let dragStart = { x: 0, y: 0 };
let offsetX = 0, offsetY = 0;
let selectedTower = null;
let placeIndex = 0, skillIndex = 0;

let learnedSkillsRegistry = new Map();
let lastLightningSpeedCheck = 0;
let lightningSpeedBuffActiveUntil = 0;
let previousGameSpeed = 1;
let skillPausedSpeed = 1; 
let guaranteedFirstTowerType = null;
let castleCostTacticApplied = false;
let freeCastleCharges = 0;

let kingRegenPerWave = 0;
let enemyHpDebuff = 0;
let kingShieldCharges = 0;
let hasKingShield = false;

// éš¨æ©Ÿé¼“èˆç›¸é—œ (æ›´æ–°)
let inspiredBuffs = []; // { slot: index, expire: time }
let nextInspireTime = 0;
const inspireInterval = 15000; // æ¯15ç§’
const inspireDuration = 20000; // æŒçºŒ20ç§’

let globalBuffs = { atkBuff: 0, rangeBuff: 0, splashBuff: 0, speedBuff1Star: 0 };

let fixedCostActive = false; 

// å¿…å‹å¡”ç›¸é—œè®Šæ•¸
let victoryInstant3StarCharges = 0; // æ¥ä¸‹ä¾†å¤šå°‘å€‹å¡”è®Š3æ˜Ÿ
let blackHoles = []; // æˆ°å ´ä¸Šçš„é»‘æ´
let bossHpOverride = 0; // Bossè¡€é‡è¦†è“‹

// --- è²»ç”¨è¨ˆç®— ---
function calculatePlaceCost(n) {
  if (fixedCostActive) return 2000;

  if (n === 0) return 1;
  let a = 1, b = 2;
  if (n === 1) return b;
  for (let i = 2; i <= n; i++) {
    let c = a + b; a = b; b = c;
  }
  return Math.min(b, 5000);
}
function calculateSkillCost(n) {
  if (fixedCostActive) return 2000;

  if (n === 0) return 500;
  let a = 500, b = 1000;
  if (n === 1) return b;
  for (let i = 2; i <= n; i++) {
    let c = a + b; a = b; b = c;
  }
  return Math.min(b, 10000);
}

function getCastleCost() {
    if (freeCastleCharges > 0) return 0;
    if (window.castleCostTacticApplied) return 1000;
    return 2000;
}

const castleSkills = [
  {name:'æ€ªç‰©å€’é€€', desc:'æ‰€æœ‰æ€ªç‰©å€’é€€å›èµ·é»1ç§’', effect:1},
  {name:'æ“Šæ•—å…©æ€ª', desc:'éš¨æ©Ÿæ“Šæ•—å…©éš»æ€ªç‰©', effect:2},
  {name:'æ€ªç‰©åœæ­¢', desc:'æ‰€æœ‰æ€ªç‰©åœæ­¢3ç§’', effect:3},
  {name:'å›å¾©è¡€é‡', desc:'åœ‹ç‹å›å¾©4é»è¡€é‡', effect:4},
  {name:'åŠè¡€æ€ªç‰©', desc:'æ¥ä¸‹ä¾†5éš»æ€ªç‰©åŠè¡€', effect:5}
];
let nextMonstersHalfHp = 0;
let monsterStunTime = 0;

let gold = 5001, wave = 1, hp = 30;
let towers = [], enemies = [], projectiles = [];

// --- å¡”é¡å‹ ---
window.towerTypes = [
  {name:'ğŸ¹å¼“ç®­å¡”', emoji:'ğŸ¹', color:'#8B4513', proj:'ğŸ¹', baseRange:8, baseDmg:10, baseRate:60000, 
   skills:[
     {name:'é›™é‡å°„æ“Š', desc:'ğŸ¹åŒæ™‚æ”»æ“Š2å€‹ç›®æ¨™', effect:'multi', value:2},
     {name:'ç ´é­”çŸ¢', desc:'â¤å°Bossé€ æˆ5å€å‚·å®³', effect:'boss_dmg', value:5},
     {name:'æš´æ“Šæ©Ÿç‡', desc:'ğŸ’¥60%æ©Ÿç‡3å€å‚·å®³', effect:'crit', value:0.6},
     {name:'ç¥è©±ç®­', desc:'â­>1æ˜Ÿå¼“ç®­å¡”æ”»é€Ÿè®Šç‚º0.1ç§’', effect:'mythic_arrow', value:0.1}
   ]},
  {name:'âœ¨é­”æ³•å¡”', emoji:'âœ¨', color:'#4169E1', proj:'âœ¨', baseRange:7, baseDmg:20, baseRate:1000, 
   skills:[
     {name:'é€£é–é–ƒé›»', desc:'âœ¦æ”»æ“ŠåŒé¡å‹æ‰€æœ‰æ•µäºº(60%å‚·å®³)', effect:'chain', value:0.6},
     {name:'æ¸›é€Ÿé ˜åŸŸ', desc:'ğŸŒ«ï¸ä¸»ç›®æ¨™æ¸›é€Ÿ90%', effect:'slow', value:0.90},
     {name:'é­”åŠ›ç‡ƒç‡’', desc:'ğŸ”¥ä¸»ç›®æ¨™æŒçºŒç‡ƒç‡’(å¡”50%å‚·å®³/0.2s)', effect:'burn', value:0.5}, 
     {name:'å¥§è¡“å¼·åŒ–', desc:'âœ¨ä½¿æ‰€æœ‰éé­”æ³•å¡”æ”»æ“ŠåŠ›+20%', effect:'global_amp', value:0.2}
   ]},
  {name:'ğŸ’£ç‚®å¡”', emoji:'ğŸ’£', color:'#B22222', proj:'ğŸ’£', baseRange:5, baseDmg:50, baseRate:3000, splash:3, 
   skills:[
     {name:'ç¯„åœæ“´å¼µ', desc:'ğŸ’¥çˆ†ç‚¸ç¯„åœ+100%', effect:'splash', value:2},
     {name:'é‡å‹ç‚®å½ˆ', desc:'ğŸ’£å‚·å®³æ°¸ä¹…+100%', effect:'dmg', value:2},
     {name:'éœ‡æ‡¾ç‚®æ³¢', desc:'âš¡æ“Šä¸­çœ©æšˆ0.5ç§’', effect:'stun', value:500},
     {name:'é›†ä¸­ç«åŠ›', desc:'ğŸ¯å°ä¸»ç›®æ¨™é¡å¤–+150å‚·å®³', effect:'focus_fire', value:150}
   ]},
  {name:'âš¡é›·å¡”', emoji:'âš¡', color:'#FF8C00', proj:'âš¡', baseRange:6, baseDmg:5, baseRate:100000,
   skills:[
     {name:'ç¾¤é«”æ”»æ“Š', desc:'âš¡ä¸€æ¬¡æ”»æ“Š5å€‹ç›®æ¨™', effect:'multi', value:5},
     {name:'è¶…é€Ÿæ”¾é›»', desc:'âš¡æ¯7ç§’å¿…å®šä½¿å…¨é›·å¡”æ”»é€Ÿè®Šç‚º0.05ç§’ (æŒçºŒ3ç§’)', effect:'super_charge', value:50}, 
     {name:'æ¥µé å°„ç¨‹', desc:'ğŸŒ©ï¸å°„ç¨‹å¢åŠ 100%', effect:'range', value:2},
     {name:'é–ƒé›»éè¼‰', desc:'âš¡æ¯10ç§’å°å…¨é«”æ•µäºº50å€å‚·å®³', effect:'global_overload', value:10000}
   ]},
  {name:'ğŸ’°é‡‘å¹£å¡”', emoji:'ğŸ’°', color:'#FFD700', proj:'ğŸ’°', baseRange:0, baseDmg:0, baseRate:0,
   skills:[
     {name:'é‰…é¡è²¡å¯Œ', desc:'ğŸª™ç«‹å³ç²å¾—20000é‡‘å¹£', effect:'grant_gold', value: 20000},
     {name:'åˆ©æ¯ç”Ÿè²¡', desc:'ğŸ“ˆæ¯5ç§’è‡ªå‹•åŠ ç›®å‰é‡‘å¹£é‡çš„1%', effect:'interest', value: 0.01},
     {name:'å¸‚å ´å£Ÿæ–·', desc:'âš–ï¸ä½¿æ”¾ç½®å’ŒæŠ€èƒ½çš„è²»ç”¨åœ¨æœ¬å±€ä¸­æ°¸ä¹…ç‚º$2000', effect:'fixed_cost', value: 2000},
     {name:'è²¡å¯Œæš´æ“Š', desc:'âœ–ï¸ä½¿ç›®å‰çš„é‡‘å¹£æ•¸é‡ä¹˜å', effect:'multiply_gold', value: 10}
   ]},
  {name:'âœŒï¸å¿…å‹å¡”', emoji:'âœŒï¸', color:'#C0C0C0', proj:'âœŒï¸', baseRange:0, baseDmg:0, baseRate:0, 
   skills:[
     {name:'è™›ç©ºé»‘æ´', desc:'âš«æˆ°å ´æ­£ä¸­å¬å–šå·¨å‹é»‘æ´ï¼Œæ•µäººé€²å…¥æ‰£50%æœ€å¤§è¡€é‡ä¸”ç„¡æ³•è¢«æ²»ç™‚', effect:'black_hole', value:2000000},
     {name:'æ˜Ÿç´šèºé·', desc:'ğŸŒŸæ¥ä¸‹ä¾†5æ¬¡æ”¾ç½®çš„å¡”ç›´æ¥è®Šç‚º3æ˜Ÿ', effect:'instant_3_star', value:5},
     {name:'ç¥ä¹‹åŠ å†•', desc:'ğŸ‘‘ç«‹å³å°‡æ‰€æœ‰å¡”(é™¤âœŒï¸å¤–)å‡è‡³5æ˜Ÿ', effect:'all_5_star', value:1},
     {name:'çµ‚å±€é™è‡¨', desc:'ğŸ’€ç«‹å³é€²å…¥ç¬¬10é—œï¼ŒBossä»¥12345çš„è¡€é‡ç™»å ´', effect:'skip_to_wave_10', value:1}
   ]},
  {name:'â¤ï¸ç”Ÿå‘½å¡”', emoji:'â¤ï¸', color:'#FF69B4', proj:'â¤ï¸', baseRange:1, baseDmg:-1000, baseRate:10000, 
   skills:[
     {name:'åœ‹ç‹ç¥ç¦', desc:'ğŸ©¸æ¯æ³¢è‡ªå‹•ç‚ºåœ‹ç‹+5é»è¡€é‡', effect:'king_regen', value:5},
     {name:'ç”Ÿå‘½é™ç•Œ', desc:'ğŸ‘‘ä½¿åœ‹ç‹è¡€é‡ä¸Šé™ç‚º50', effect:'king_max_hp', value:50},
     {name:'ç”Ÿå‘½å‡‹é›¶', desc:'ğŸ’¯ä½¿æ‰€æœ‰æ€ªç‰©æ¯æ³¢ç™»å ´æ™‚éƒ½å°‘10%è¡€', effect:'enemy_hp_debuff', value:0.1},
     {name:'ç¥è–åº‡è­·', desc:'ğŸ›¡ï¸ä½¿åœ‹ç‹æ¯æ³¢éƒ½èƒ½å…ç–«3æ¬¡å‚·å®³', effect:'king_shield', value:3}
   ]},
  {name:'ğŸ‘é¼“å‹µå¡”', emoji:'ğŸ‘', color:'#FFB6C1', proj:'ğŸ‘', baseRange:0, baseDmg:0, baseRate:0, 
   skills:[
     {name:'å£«æ°£é«˜æ¼²', desc:'æ¯å­˜åœ¨1å€‹ğŸ‘å¡”ï¼Œå…¶ä»–1æ˜Ÿå¡”+20æ”»', effect:'global_atk_buff', value:20},
     {name:'è¦–é‡æ“´å±•', desc:'æ¯å­˜åœ¨1å€‹ğŸ‘é¼“å‹µå¡”ï¼Œå…¶ä»–1æ˜Ÿå¡”çš„æ”»é€Ÿ+80%', effect:'global_speed_buff_1star', value:0.8},
     {name:'ç‰¹æ®Šå¡”æ§½', desc:'ğŸ”²ç”Ÿæˆä¸€å€‹èƒ½å®¹ç´4å€‹å¡”çš„å¡”æ§½', effect:'special_slot', value:1},
     {name:'éš¨æ©Ÿé¼“èˆ', desc:'æ¯15ç§’é¼“èˆ2å€‹éé¼“å‹µå¡”çš„å¡”æ§½ï¼Œæ”»é€Ÿã€æ”»æ“Šã€å°„ç¨‹+50%ï¼ŒæŒçºŒ20ç§’', effect:'inspire_slot', value:1}
   ]}
];

// --- æ•µäºº ---
const enemyTypes = [
  {hp:50, speed:1, gold:500, emoji:'ğŸ‘¹', isBoss: false}, 
  {hp:25, speed:2, gold:500, emoji:'ğŸ¦‡', isBoss: false}, 
  {hp:200, speed:0.5, gold:500, emoji:'ğŸ²', isBoss: false}, 
  {hp:100,speed:1, gold:500, emoji:'ğŸ¤–', isBoss: false, isRanged: true},
  {hp:2000, speed:0.5, gold:50000, emoji:'ğŸ‘º', isBoss: true}, 
  {hp:99999, speed:3, gold:50000, emoji:'ğŸ˜ˆ', isBoss: true, isFinalBoss: true}, 
  {hp:999, speed:1, gold:-1000, emoji:'ğŸ‘»', isBoss: false, isRanged: true},
  {hp:30, speed:0.5, gold:500, emoji:'ğŸ‘½', isBoss: false, isHealer: true}, 
  {hp:30, speed:0.5, gold:0, emoji:'â˜ ï¸', isBoss: false, revivesTo: 9}, 
  {hp:5, speed:4, gold:500, emoji:'ğŸ’€', isBoss: false} 
];

// --- é»‘æ´é¡åˆ¥ ---
class BlackHole {
    constructor(x, y, duration) {
        this.x = x;
        this.y = y;
        this.radius = TILE * 4; // å·¨å‹åœ“ç‹€
        this.expiresAt = gameTime + duration;
        this.hitList = new Set(); // è¨˜éŒ„å·²ç¶“è¢«æ­¤é»‘æ´æ‰£è¡€çš„æ€ªç‰©ID
    }
    
    update() {
        if (gameTime > this.expiresAt) return true; // çµæŸ
        
        enemies.forEach(e => {
            if (e.hp <= 0) return;
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            
            if (d < this.radius) {
                // é€²å…¥é»‘æ´æ•ˆæœ
                e.hasVoidDebuff = true; // æ°¸ä¹…ç„¡æ³•å—æ²»ç™‚
                
                // æ‰£50%è¡€é‡ (åƒ…ä¸€æ¬¡)
                if (!this.hitList.has(e)) {
                    const dmg = e.maxHp * 0.5;
                    e.hp -= dmg;
                    this.hitList.add(e);
                    if (e.hp <= 0) onEnemyDeath(e);
                    updateUI();
                }
            }
        });
        return false;
    }
    
    draw() {
        ctx.save();
        // é»‘æ´è¦–è¦ºæ•ˆæœ
        const grad = ctx.createRadialGradient(this.x, this.y, this.radius * 0.2, this.x, this.y, this.radius);
        grad.addColorStop(0, 'black');
        grad.addColorStop(0.5, 'rgba(50, 0, 80, 0.8)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // æ—‹è½‰ç²’å­
        const angle = (gameTime / 500) % (Math.PI * 2);
        ctx.strokeStyle = 'rgba(138, 43, 226, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.7, angle, angle + Math.PI);
        ctx.stroke();
        ctx.restore();
    }
}

// --- æ³¢æ¬¡æ§åˆ¶ ---
let waveEnemies = 0, waveSpawned = 0, waveDelay = 0;
let spawnIntervalBase = 900;
let nextSpawnAt = 0;
let currentEnemyTypes = []; 
let lastMinionSpawn = 0; 

function startWave() {
  if (wave > 10) { gameOver(true); return; }
  
  hp = Math.min(maxHp, hp + kingRegenPerWave);
  if (hasKingShield) { kingShieldCharges = 1; }

  if (window.activeTactic && window.activeTactic.id === 'gold_rush') {
      const goldTowers = towers.filter(t => t.type.name === 'ğŸ’°é‡‘å¹£å¡”' && t.stars === 1).length;
      if (goldTowers > 0) {
          gold += goldTowers * 1;
      }
  }

  let enemyTypeIndices = [];
  if (wave === 5) {
    waveEnemies = 1; enemyTypeIndices = [4]; spawnIntervalBase = 100; 
  } else if (wave === 10) {
    waveEnemies = 1; enemyTypeIndices = [5]; spawnIntervalBase = 100;
  } else {
    waveEnemies = 3 + wave * 6;
    const standardEnemyIndices = [0, 1, 2, 3, 7, 8]; 
    let indices = new Set();
    while(indices.size < 3) {
        indices.add(standardEnemyIndices[Math.floor(Math.random() * standardEnemyIndices.length)]);
    }
    enemyTypeIndices = Array.from(indices); 
    spawnIntervalBase = 900;
  }
  currentEnemyTypes = enemyTypeIndices; 
  waveSpawned = 0;
  waveDelay = 500;
  nextSpawnAt = gameTime + waveDelay;
  ui.wave.textContent = wave;
  lastMinionSpawn = gameTime; 
  
  updateUI(); 
}
function spawnEnemy() {
    const randomTypeIdx = currentEnemyTypes[Math.floor(Math.random() * currentEnemyTypes.length)];
    enemies.push(new Enemy(randomTypeIdx));
    waveSpawned++;
}
function spawnMinion() { enemies.push(new Enemy(6)); }

// --- åŸå ¡å’Œå¡”æ§½ ---
function getCastleSlots() { return slots; }
function initSlots() {
  slots = [];
  const initialY = Math.max(0, Math.floor(rows * BASELINE_Y) - 1);
  for (let i = 0; i < 7; i++) {
    slots.push({ x: i, y: initialY, w: 1, isSpecial: false });
  }
}
function addNewSlot() {
  let possible = [];
  for (const sl of slots) {
    const candidates = [{x: sl.x - 1, y: sl.y}, {x: sl.x + 1, y: sl.y}, {x: sl.x, y: sl.y - 1}, {x: sl.x, y: sl.y + 1}];
    for (const c of candidates) {
      if (c.x >= 0 && c.x < cols && c.y >= 0 && c.y <= castleY && !slots.some(s => s.x === c.x && s.y === c.y)) {
        possible.push(c);
      }
    }
  }
  if (possible.length > 0) {
    const rand = possible[Math.floor(Math.random() * possible.length)];
    slots.push({ x: rand.x, y: rand.y, w: 1, isSpecial: false });
    return slots.length - 1; 
  }
  return -1;
}

function drawCastle() {
  const currentSlots = getCastleSlots();
  const slotPixelY = currentSlots.length > 0 ? currentSlots[0].y * TILE : (gameHeight * BASELINE_Y);
  
  ctx.fillStyle = '#654321';
  ctx.fillRect(0, slotPixelY, gameWidth, gameHeight - slotPixelY);
  
  currentSlots.forEach((slot, i) => {
    // æª¢æŸ¥æ­¤æ§½ä½æ˜¯å¦æœ‰è¢«é¼“èˆ
    const inspired = inspiredBuffs.find(b => b.slot === i && b.expire > gameTime);
    if (inspired) {
        ctx.fillStyle = 'rgba(255, 223, 0, 0.5)'; 
        const glowPad = TILE * 0.15;
        ctx.fillRect((slot.x * TILE) - glowPad, (slot.y * TILE) - glowPad, (slot.w * TILE) + (glowPad * 2), TILE + (glowPad * 2));
    }
    
    const slotWidth = slot.w * TILE;
    const slotX = slot.x * TILE;
    const slotY = slot.y * TILE;

    if (slot.isSpecial) {
        ctx.fillStyle = 'rgba(255, 215, 0, 0.2)'; 
        ctx.fillRect(slotX, slotY, slotWidth, TILE);
        ctx.strokeStyle = '#FFD700'; 
        ctx.lineWidth = 3;
        ctx.strokeRect(slotX, slotY, slotWidth, TILE);
        const subSize = TILE / 2;
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(slotX + subSize, slotY); ctx.lineTo(slotX + subSize, slotY + TILE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(slotX, slotY + subSize); ctx.lineTo(slotX + TILE, slotY + subSize); ctx.stroke();
    } else {
        const occupied = towers.some(t => t.slot === i);
        ctx.fillStyle = occupied ? 'rgba(0,200,100,0.3)' : '#FFFFFF';
        ctx.fillRect(slotX, slotY, slotWidth, TILE);
        ctx.strokeStyle = '#333333'; 
        ctx.lineWidth = 3;
        ctx.strokeRect(slotX, slotY, slotWidth, TILE);
    }
  });
  positionBottomControls(slotPixelY, gameHeight - slotPixelY);
}
function drawGrid() {
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  for(let x=0; x<=cols; x++) { ctx.beginPath(); ctx.moveTo(x*TILE, 0); ctx.lineTo(x*TILE, gameHeight); ctx.stroke(); }
  for(let y=0; y<=rows; y++) { ctx.beginPath(); ctx.moveTo(0, y*TILE); ctx.lineTo(gameWidth, y*TILE); ctx.stroke(); }
}
function drawTowerRange(tower) {
  if (!tower) return;
  ctx.save();
  ctx.beginPath();
  
  let centerX, centerY, drawSize;
  if (tower.subSlot !== null) {
      drawSize = TILE / 2;
      centerX = (tower.x * TILE) + (drawSize / 2);
      centerY = (tower.y * TILE) + (drawSize / 2);
  } else {
      drawSize = TILE;
      centerX = (tower.x * TILE) + (drawSize / 2);
      centerY = (tower.y * TILE) + (drawSize / 2);
  }

  // é¡¯ç¤ºç¯„åœæ™‚è€ƒæ…®é¼“èˆæ•ˆæœ
  let displayRange = tower.range;
  const isInspired = inspiredBuffs.some(b => b.slot === tower.slot && b.expire > gameTime);
  
  // æ³¨æ„: update() è£¡é¢å·²ç¶“è¨­å®šäº† tower.range åŒ…å«äº† buffï¼Œä½†å¦‚æœæš«åœæ™‚é‡ç¹ªå¯èƒ½æœƒæœ‰èª¤å·®
  // æ­¤è™•æˆ‘å€‘ç›´æ¥å– tower.rangeï¼Œç¢ºä¿ update() é‚è¼¯æ­£ç¢ºå³å¯
  // ä½† drawTowerRange å¯èƒ½åœ¨ update å‰å‘¼å«ï¼Œä¿éšªèµ·è¦‹é€™è£¡ä¸é‡è¤‡è¨ˆç®—ï¼Œä¾è³´ update æ›´æ–°å¾Œçš„æ•¸å€¼

  ctx.arc(centerX, centerY, displayRange, 0, 2 * Math.PI); 
  ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; ctx.fill();
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.stroke();
  ctx.restore();
}

function getNewMergedTowerType(originalTowerType) {
  if (window.selectedDeckTypes && window.selectedDeckTypes.length > 1 && Math.random() < 0.4) { 
    const deckOtherTypes = window.selectedDeckTypes.filter(t => t !== originalTowerType);
    if (deckOtherTypes.length > 0) return deckOtherTypes[Math.floor(Math.random() * deckOtherTypes.length)];
  }
  return originalTowerType; 
}

// --- Tower é¡åˆ¥ ---
class Tower {
  constructor(slotIndex, type, stars = 1, subSlotIndex = null) {
    const slot = slots[slotIndex];
    this.slot = slotIndex;
    this.subSlot = subSlotIndex;
    
    if (this.subSlot !== null) {
        this.x = slot.x + (this.subSlot % 2) * 0.5;
        this.y = slot.y + Math.floor(this.subSlot / 2) * 0.5;
    } else {
        this.x = slot.x; 
        this.y = slot.y; 
    }

    this.type = type;
    this.stars = stars;
    this.baseRangeTiles = type.baseRange; 
    
    if (this.type.name === 'â¤ï¸ç”Ÿå‘½å¡”' || this.type.name === 'ğŸ‘é¼“å‹µå¡”' || this.type.name === 'ğŸ’°é‡‘å¹£å¡”') {
      this.range = this.baseRangeTiles * TILE; 
    } else {
      this.range = this.baseRangeTiles * TILE; 
    }
    
    const dmgMultiplier = Math.pow(2, stars - 1);
    this.dmg = type.baseDmg * dmgMultiplier; 
    
    this.rate = type.baseRate; 
    
    if (this.type.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
        this.rate = 10000 + (stars - 1) * 5000;
    }

    // --- æ‡‰ç”¨æˆ°è¡“ ---
    if (window.activeTactic && this.stars === 1) {
        const tactic = window.activeTactic;
        if (tactic.id === 'magic_buff' && this.type.name === 'âœ¨é­”æ³•å¡”') {
            this.dmg *= 1.7;
            this.rate *= 0.3; 
        } else if (tactic.id === 'cannon_kill' && this.type.name === 'ğŸ’£ç‚®å¡”') {
            this.dmg *= (1 + (window.tacticCannonKills * 0.03)); 
        } else if (tactic.id === 'lightning_speed' && this.type.name === 'âš¡é›·å¡”') {
            this.rate = 200; 
        } else if (tactic.id === 'confidence' && this.type.name === 'âœŒï¸å¿…å‹å¡”') {
            this.dmg = 0; 
            this.rate = 2000; 
            this.range = 2 * TILE; 
            this.isConfidenceActive = true; 
        }
    }

    this.color = type.color;
    this.emoji = type.emoji;
    this.proj = type.proj;
    this.splash = type.splash || 0;
    this.lastShot = 0;
    this.multiTarget = 1;
    this.appliedSkills = []; 
    this.isConfidenceActive = this.isConfidenceActive || false;
    
    this.lastInterestTime = gameTime;

    const globallyLearned = learnedSkillsRegistry.get(type.name);
    if (globallyLearned) {
        globallyLearned.forEach(skillName => {
            const skill = type.skills.find(s => s.name === skillName);
            if (skill) this.applySkill(skill); 
        });
    }
    
    this.appliedSkills.forEach(skill => {
        if (skill.effect === 'rate_decrease') this.rate -= skill.value;
    });
    
    this.lastGlobalOverload = 0; 
  }

  update() {
    const now = gameTime;
    const { atkBuff, rangeBuff, splashBuff, speedBuff1Star } = globalBuffs; 

    if (this.type.name === 'ğŸ’°é‡‘å¹£å¡”') {
        const interestSkill = this.appliedSkills.find(s => s.effect === 'interest');
        if (interestSkill) {
            if (now - this.lastInterestTime >= 5000) { 
                this.lastInterestTime = now;
                const interest = Math.floor(gold * interestSkill.value);
                if (interest > 0) {
                    gold += interest;
                    updateUI();
                }
            }
        }
        return; 
    }
    
    const globalOverloadSkill = this.appliedSkills.find(s => s.effect === 'global_overload');
    if (globalOverloadSkill && (now - this.lastGlobalOverload > globalOverloadSkill.value)) {
        this.lastGlobalOverload = now;
        const overloadDmg = this.dmg * 50; 
        enemies.forEach(e => {
            if (e.hp > 0) {
                let finalOverloadDmg = overloadDmg;
                if (e.type.emoji === 'ğŸ²') { finalOverloadDmg *= 0.95; }
                e.hp -= finalOverloadDmg;
                if (e.hp <= 0) onEnemyDeath(e);
            }
        });
        updateUI(); 
    }

    let effectiveRate = this.rate; 
    let effectiveDmg = this.dmg;
    
    // åŸºç¤å°„ç¨‹é‡ç½®ï¼Œä»¥ä¾¿æ‡‰ç”¨å‹•æ…‹Buff (å¦‚é¼“èˆ)
    let currentRange = this.range; // é€™æ˜¯å·²ç¶“åŒ…å«éœæ…‹æŠ€èƒ½Rangeçš„æ•¸å€¼

    // æª¢æŸ¥æ˜¯å¦è¢«é¼“èˆ (éš¨æ©Ÿé¼“èˆ)
    const inspireBuff = inspiredBuffs.find(b => b.slot === this.slot && b.expire > now);
    
    if (this.type.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
        effectiveRate = 10000 + (this.stars - 1) * 5000;
    }
    else if (this.isConfidenceActive) {
        effectiveRate = 2000;
    } else {
        this.appliedSkills.forEach(skill => {
            if (skill.effect === 'rate') effectiveRate *= (1 - skill.value);
        });

        // æ‡‰ç”¨ "è¦–é‡æ“´å±•" çš„æ”»é€ŸBuff
        if (this.stars === 1 && speedBuff1Star > 0) {
             effectiveRate /= (1 + speedBuff1Star);
        }

        if (this.type.name === 'âš¡é›·å¡”' && now < lightningSpeedBuffActiveUntil) {
            const lightningType = window.towerTypes.find(t => t.name === 'âš¡é›·å¡”');
            const superChargeSkill = lightningType.skills.find(s => s.name === 'è¶…é€Ÿæ”¾é›»');
            const skillValue = superChargeSkill ? superChargeSkill.value : 50;
            effectiveRate = skillValue; 
        }

        const mythicSkill = this.appliedSkills.find(s => s.effect === 'mythic_arrow');
        if (mythicSkill && this.type.name === 'ğŸ¹å¼“ç®­å¡”' && this.stars > 1) {
            effectiveRate = mythicSkill.value * 1000;
        }
    }
    
    // æ‡‰ç”¨éš¨æ©Ÿé¼“èˆ Buff
    if (inspireBuff) {
        // æ”»é€Ÿ +50% -> å»¶é² / 1.5
        effectiveRate /= 1.5;
        // æ”»æ“Š +50%
        effectiveDmg *= 1.5;
        // å°„ç¨‹ +50%
        currentRange *= 1.5;
    }
    
    // æ›´æ–°ç•¶å‰å°„ç¨‹ä»¥ä¾›ç¹ªè£½å’Œåˆ¤æ–·
    this.currentDisplayRange = currentRange; // æš«å­˜çµ¦ draw ä½¿ç”¨

    if (effectiveRate <= 0) return; 
    if (now - this.lastShot < effectiveRate) return;
    
    let centerX, centerY, drawSize;
    if (this.subSlot !== null) {
        drawSize = TILE / 2;
        centerX = (this.x * TILE) + (drawSize / 2);
        centerY = (this.y * TILE) + (drawSize / 2);
    } else {
        drawSize = TILE;
        centerX = (this.x * TILE) + (drawSize / 2);
        centerY = (this.y * TILE) + (drawSize / 2);
    }

    if (this.type.baseRange > 0) { 
        currentRange += rangeBuff;
    }

    let targets = [];
    for (const e of enemies) {
      if (e.hp <= 0) continue; 
      const d = Math.hypot(e.x - centerX, e.y - centerY); 
      if (d <= currentRange + 5) targets.push({ e, d }); 
    }
    
    if (targets.length === 0) return;
    targets.sort((a, b) => a.d - b.d);
    
    const shootCount = Math.min(targets.length, this.multiTarget);
    this.lastShot = now;
    
    if (this.type.name === 'â¤ï¸ç”Ÿå‘½å¡”') { playHealSound(); } else { playShotSound(); }

    let globalBuff = 0;
    if (this.type.name !== 'âœ¨é­”æ³•å¡”') {
        towers.forEach(t => {
            if (t && t.type && t.type.name === 'âœ¨é­”æ³•å¡”' && t.appliedSkills.some(s => s.effect === 'global_amp')) {
                const ampSkill = t.appliedSkills.find(s => s.effect === 'global_amp');
                if (ampSkill) globalBuff += ampSkill.value; 
            }
        });
    }

    for (let i = 0; i < shootCount; i++) {
      // ä½¿ç”¨ç¶“é Buff è¨ˆç®—å¾Œçš„ effectiveDmg
      let finalDmg = effectiveDmg;
      
      if (this.type.name !== 'â¤ï¸ç”Ÿå‘½å¡”') { finalDmg *= (1 + globalBuff); }
      
      let isCrit = false;
      
      let confidenceDmg = 0;
      if (this.isConfidenceActive) {
          confidenceDmg = targets[i].e.maxHp * 0.05;
          finalDmg = 0; 
      }
      
      const bossDmgSkill = this.appliedSkills.find(s => s.effect === 'boss_dmg');
      if (bossDmgSkill && targets[i].e.type.isBoss) finalDmg *= bossDmgSkill.value;

      const critSkill = this.appliedSkills.find(s => s.effect === 'crit');
      if (critSkill && Math.random() < critSkill.value) { finalDmg *= 3; isCrit = true; }
      
      if (this.stars === 1 && this.type.baseDmg > 0) {
          finalDmg += atkBuff;
      }
      
      projectiles.push(new Projectile(
        centerX, centerY, 
        targets[i].e, finalDmg, this.proj, this.color, 
        this.splash + splashBuff, 
        isCrit, 
        this.appliedSkills, this.stars,
        confidenceDmg 
      ));
    }
  }

  draw(inset = true) {
    let drawX, drawY, drawSize;
    let centerX, centerY;
    
    if (this.subSlot !== null) {
        drawSize = TILE / 2;
        drawX = this.x * TILE; 
        drawY = this.y * TILE; 
        centerX = drawX + drawSize / 2;
        centerY = drawY + drawSize / 2;
    } else {
        drawSize = TILE;
        drawX = this.x * TILE;
        drawY = this.y * TILE;
        centerX = drawX + drawSize / 2;
        centerY = drawY + drawSize / 2;
    }

    ctx.fillStyle = this.color;
    
    if (inset) {
      const ins = 3;
      ctx.fillRect(drawX + ins, drawY + ins, drawSize - 2 * ins, drawSize - 2 * ins);
    } else {
      ctx.fillRect(drawX, drawY, drawSize, drawSize);
    }

    const fontSize = drawSize * Math.max(0.3, 0.8 - this.stars * 0.1);
    ctx.font = `${fontSize}px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = (this.type.name === 'ğŸ’°é‡‘å¹£å¡”') ? '#000000' : '#FFFFFF'; 
    const padding = drawSize * 0.1; 
    ctx.fillText(this.emoji.repeat(this.stars), centerX, centerY, drawSize - padding);
  }

  applySkill(skill) {
    if (!this.appliedSkills.some(s => s.name === skill.name)) {
        this.appliedSkills.push(skill);
        if (skill.effect === 'multi') this.multiTarget = skill.value;
        
        if (skill.effect === 'range' && !['â¤ï¸ç”Ÿå‘½å¡”','ğŸ‘é¼“å‹µå¡”','ğŸ’°é‡‘å¹£å¡”'].includes(this.type.name)) { 
          this.range = this.baseRangeTiles * TILE; 
          this.range *= skill.value;
        }
        if (skill.effect === 'range_add' && !['â¤ï¸ç”Ÿå‘½å¡”','ğŸ‘é¼“å‹µå¡”','ğŸ’°é‡‘å¹£å¡”'].includes(this.type.name)) { 
             this.range += skill.value * TILE;
        }

        if (skill.effect === 'dmg') this.dmg *= skill.value;
        if (skill.effect === 'splash') this.splash *= skill.value;
        if (skill.effect === 'rate_decrease') this.rate -= skill.value;
    }
  }

  getInfo() {
    const { atkBuff, rangeBuff, splashBuff, speedBuff1Star } = globalBuffs; 
    const inspireBuff = inspiredBuffs.find(b => b.slot === this.slot && b.expire > gameTime);

    // --- è¨ˆç®—ç¯„åœ ---
    let baseDisplayRange = this.range; // éœæ…‹æŠ€èƒ½å¾Œçš„ç¯„åœ
    if (this.type.baseRange > 0) {
        baseDisplayRange += rangeBuff;
    }
    let finalRange = baseDisplayRange;
    if (inspireBuff) finalRange *= 1.5; // é¼“èˆ +50%

    let rangeInTiles = TILE > 0 ? (finalRange / TILE).toFixed(1) : this.baseRangeTiles.toFixed(1);
    if (inspireBuff) {
        const diff = (finalRange - baseDisplayRange) / TILE;
        const remaining = Math.ceil((inspireBuff.expire - gameTime) / 1000);
        rangeInTiles = `${rangeInTiles} (+${diff.toFixed(1)}) æ ¼ï¼ŒæŒçºŒ${remaining}ç§’`;
    } else {
        rangeInTiles += " æ ¼";
    }
    
    // --- è¨ˆç®—æ”»é€Ÿ ---
    let effectiveRate = this.rate; 
    
    if (this.type.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
        effectiveRate = 10000 + (this.stars - 1) * 5000;
    }
    else if (this.isConfidenceActive) {
        effectiveRate = 2000;
    } else {
        const rateSkill = this.appliedSkills.find(s => s.effect === 'rate');
        if (rateSkill) effectiveRate *= (1 - rateSkill.value);
        
        if (this.stars === 1 && speedBuff1Star > 0) {
            effectiveRate /= (1 + speedBuff1Star);
        }

        const mythicSkill = this.appliedSkills.find(s => s.effect === 'mythic_arrow');
        if (mythicSkill && this.stars > 1) effectiveRate = mythicSkill.value * 1000;
    }

    let finalRate = effectiveRate;
    if (inspireBuff) finalRate /= 1.5; // é¼“èˆ æ”»é€Ÿ+50% (å»¶é² / 1.5)

    let secondsPerAttack = finalRate > 0 ? (finalRate / 1000).toFixed(2) : "N/A"; 
    
    if (inspireBuff && finalRate > 0) {
        const baseSec = effectiveRate / 1000;
        const finalSec = finalRate / 1000;
        const diff = finalSec - baseSec; // æ‡‰è©²æ˜¯è² å€¼
        const remaining = Math.ceil((inspireBuff.expire - gameTime) / 1000);
        secondsPerAttack = `${secondsPerAttack} (${diff.toFixed(2)}) ç§’/æ¬¡ï¼ŒæŒçºŒ${remaining}ç§’`;
    } else {
        secondsPerAttack += " ç§’/æ¬¡";
    }

    // --- è¨ˆç®—å‚·å®³ ---
    let globalBuff = 0;
    if (this.type.name !== 'âœ¨é­”æ³•å¡”' && this.type.name !== 'â¤ï¸ç”Ÿå‘½å¡”') {
        towers.forEach(t => {
            if (t && t.type && t.type.name === 'âœ¨é­”æ³•å¡”' && t.appliedSkills.some(s => s.effect === 'global_amp')) {
                const ampSkill = t.appliedSkills.find(s => s.effect === 'global_amp');
                if (ampSkill) globalBuff += ampSkill.value; 
            }
        });
    }
    
    let currentDmg = this.dmg;
    let baseFinalDmg = currentDmg * (1 + globalBuff);
    if (this.stars === 1 && this.type.baseDmg > 0) {
        baseFinalDmg += atkBuff;
    }

    let finalDmg = baseFinalDmg;
    if (inspireBuff) finalDmg *= 1.5; // é¼“èˆ +50%

    const critSkill = this.appliedSkills.find(s => s.effect === 'crit');
    const critInfo = critSkill ? ` (æš´æ“Šç‡: ${(critSkill.value * 100).toFixed(0)}%, 3å€)` : '';

    let dmgDisplay = finalDmg.toFixed(1);
    if (inspireBuff) {
        const diff = finalDmg - baseFinalDmg;
        const remaining = Math.ceil((inspireBuff.expire - gameTime) / 1000);
        dmgDisplay = `${dmgDisplay} (+${diff.toFixed(1)})ï¼ŒæŒçºŒ${remaining}ç§’`;
    }
    dmgDisplay += critInfo;
    
    if (this.isConfidenceActive) {
        dmgDisplay = "æ•µäººæœ€å¤§ç”Ÿå‘½ 5%";
    }
    if (this.type.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
        dmgDisplay = `${finalDmg.toFixed(0)} (æ²»ç™‚)`;
    }
    if (this.type.name === 'ğŸ‘é¼“å‹µå¡”' || this.type.name === 'ğŸ’°é‡‘å¹£å¡”' || this.type.name === 'âœŒï¸å¿…å‹å¡”') {
        dmgDisplay = "0";
        rangeInTiles = "0";
    }
    
    const towerSize = this.subSlot !== null ? "å°" : "æ™®é€š";

    return {
      name: this.type.name, stars: this.stars, emoji: this.emoji, 
      dmg: dmgDisplay,
      range: rangeInTiles, 
      attackSpeed: secondsPerAttack, 
      splash: (this.splash + splashBuff), 
      size: towerSize, 
      skills: this.appliedSkills.map(s => s.name).join(', ') || 'ç„¡'
    };
  }
}

// --- æ”¾ç½®å¡” ---
function placeTower() {
  const cost = calculatePlaceCost(placeIndex); 
  if (gold < cost) return;

  const emptyNormalSlots = slots.map((s, i) => ({s, i}))
      .filter(item => !item.s.isSpecial && !towers.some(t => t.slot === item.i))
      .map(item => ({ slot: item.i, subSlot: null }));

  const emptySubSlots = [];
  slots.forEach((s, i) => {
      if (s.isSpecial) {
          const towersInThisSlot = towers.filter(t => t.slot === i).map(t => t.subSlot);
          for (let j = 0; j < 4; j++) {
              if (!towersInThisSlot.includes(j)) {
                  emptySubSlots.push({ slot: i, subSlot: j });
              }
          }
      }
  });

  const allEmptySlots = [...emptyNormalSlots, ...emptySubSlots];
  if (allEmptySlots.length === 0) return; 
  
  const chosenSlot = allEmptySlots[Math.floor(Math.random() * allEmptySlots.length)];
  const slotIdx = chosenSlot.slot;
  const subSlotIdx = chosenSlot.subSlot; 
  
  let towerToPlace = null;
  if (window.guaranteedFirstTowerType && placeIndex === 0) {
      towerToPlace = window.guaranteedFirstTowerType;
  } else {
      if (window.selectedDeckTypes.length === 0) {
          const typeIdx = Math.floor(Math.random() * window.towerTypes.length);
          towerToPlace = window.towerTypes[typeIdx];
      } else {
          const randomTypeFromDeck = window.selectedDeckTypes[Math.floor(Math.random() * window.selectedDeckTypes.length)];
          towerToPlace = randomTypeFromDeck;
      }
  }
  
  if (towerToPlace) {
      let initialStars = 1;
      if (victoryInstant3StarCharges > 0) {
          initialStars = 3;
          victoryInstant3StarCharges--;
          updateUI(); 
      }

      towers.push(new Tower(slotIdx, towerToPlace, initialStars, subSlotIdx));

      if (window.activeTactic && window.activeTactic.id === 'i_love_you' && towerToPlace.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
          hp = Math.min(maxHp, hp + 3);
          playHealSound();
          updateUI();
      }

      if (window.guaranteedFirstTowerType && placeIndex === 0) {
          window.guaranteedFirstTowerType = null;
      }
  }
  
  gold -= cost;
  placeIndex++; 
  updateUI();
}

// --- æ»‘é¼ /è§¸æ§äº‹ä»¶ ---
function getMousePos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width > 0 ? canvas.width / rect.width : 1;
  const scaleY = rect.height > 0 ? canvas.height / rect.height : 1;
  mouse.x = (e.clientX - rect.left) * scaleX;
  mouse.y = (e.clientY - rect.top) * scaleY;
}
function mousedown(e) {
  getMousePos(e);
  potentialDrag = null;
  
  for (const tower of towers) {
    let cx, cy, radius;
    if (tower.subSlot !== null) {
        const drawSize = TILE / 2;
        cx = (tower.x * TILE) + (drawSize / 2);
        cy = (tower.y * TILE) + (drawSize / 2);
        radius = drawSize / 2;
    } else {
        cx = (tower.x * TILE) + (TILE / 2);
        cy = (tower.y * TILE) + (TILE / 2);
        radius = TILE / 2;
    }
    
    if (Math.hypot(mouse.x - cx, mouse.y - cy) < radius) {
      potentialDrag = tower;
      dragStart.x = mouse.x; dragStart.y = mouse.y;
      offsetX = mouse.x - cx; offsetY = mouse.y - cy;
      break;
    }
  }
}
function mousemove(e) {
  getMousePos(e);
  if (potentialDrag && !dragging) {
    const d = Math.hypot(mouse.x - dragStart.x, mouse.y - dragStart.y);
    if (d > 5) {
      dragging = true;
      draggingTower = potentialDrag;
      selectedTower = null; 
      closeTowerInfo(); 
    }
  }
}
function mouseup(e) {
  getMousePos(e);
  if (dragging) {
    let target = null;
    
    for (const t of towers) {
      if (t === draggingTower) continue;
      
      let cx, cy, radius;
      if (t.subSlot !== null) {
          const drawSize = TILE / 2;
          cx = (t.x * TILE) + (drawSize / 2);
          cy = (t.y * TILE) + (drawSize / 2);
          radius = drawSize / 2;
      } else {
          cx = (t.x * TILE) + (TILE / 2);
          cy = (t.y * TILE) + (TILE / 2);
          radius = TILE / 2;
      }

      if (Math.hypot(mouse.x - cx, mouse.y - cy) < radius) {
        target = t; break;
      }
    }

    if (target && target.type === draggingTower.type && target.stars === draggingTower.stars && target.stars < 5) {
      const targetIsSmall = (target.subSlot !== null);
      const draggingIsSmall = (draggingTower.subSlot !== null);

      if (targetIsSmall === draggingIsSmall) {
          const originalType = target.type; 
          const newType = getNewMergedTowerType(originalType);
          const newStars = target.stars + 1;
          const newMergedTower = new Tower(target.slot, newType, newStars, target.subSlot); 
          towers = towers.filter(t => t !== draggingTower && t !== target);
          towers.push(newMergedTower);
          if (selectedTower === target || selectedTower === draggingTower) {
              selectedTower = newMergedTower;
              showTowerInfo(selectedTower);
          }
      }
    } else {
      let droppedOnSlot = false;
      for (let i = 0; i < slots.length; i++) {
        const slot = slots[i];
        
        if (slot.isSpecial) {
            const subSize = TILE / 2;
            for (let j = 0; j < 4; j++) {
                const subX = (slot.x * TILE) + (j % 2) * subSize;
                const subY = (slot.y * TILE) + Math.floor(j / 2) * subSize;
                const cx = subX + subSize / 2;
                const cy = subY + subSize / 2;
                
                if (Math.hypot(mouse.x - cx, mouse.y - cy) < subSize / 2) {
                    const occupied = towers.some(t => t.slot === i && t.subSlot === j);
                    if (!occupied && draggingTower.subSlot !== null) {
                        draggingTower.slot = i;
                        draggingTower.subSlot = j;
                        draggingTower.x = slot.x + (j % 2) * 0.5;
                        draggingTower.y = slot.y + Math.floor(j / 2) * 0.5;
                        droppedOnSlot = true; break;
                    }
                }
            }
            if (droppedOnSlot) break;
            
        } else {
            const cx = (slot.x * TILE) + (TILE / 2);
            const cy = (slot.y * TILE) + (TILE / 2);
            if (Math.hypot(mouse.x - cx, mouse.y - cy) < TILE / 2) {
                const occupied = towers.some(t => t.slot === i);
                if (!occupied && draggingTower.subSlot === null) {
                    draggingTower.slot = i;
                    draggingTower.subSlot = null; 
                    draggingTower.x = slot.x; 
                    draggingTower.y = slot.y;
                    droppedOnSlot = true; break;
                }
            }
        }
      }
    }
    dragging = false; draggingTower = null;
  } else if (potentialDrag) {
    selectedTower = potentialDrag;
    showTowerInfo(potentialDrag);
  }
  potentialDrag = null;
}
canvas.addEventListener('mousedown', mousedown);
canvas.addEventListener('mousemove', mousemove);
canvas.addEventListener('mouseup', mouseup);
canvas.addEventListener('touchstart', (e) => mousedown(e.touches[0]));
canvas.addEventListener('touchmove', (e) => mousemove(e.touches[0]));
canvas.addEventListener('touchend', (e) => mouseup(e.changedTouches[0]));

// --- è³‡è¨Šå½ˆçª— ---
function showTowerInfo(tower) {
  // é‡ç½®æ¨£å¼
  const infoTitle = document.getElementById('towerInfoTitle');
  const infoContent = document.getElementById('towerInfoContent');
  
  infoTitle.classList.remove('life-tower', 'encourage-tower', 'gold-tower', 'win-tower');
  infoContent.classList.remove('life-tower', 'encourage-tower', 'gold-tower', 'win-tower');
  towerInfoModal.classList.remove('life-tower', 'encourage-tower', 'gold-tower', 'win-tower');
  
  if (tower.type.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
    infoTitle.classList.add('life-tower');
    infoContent.classList.add('life-tower');
    towerInfoModal.classList.add('life-tower');
  } else if (tower.type.name === 'ğŸ‘é¼“å‹µå¡”') {
    infoTitle.classList.add('encourage-tower');
    infoContent.classList.add('encourage-tower');
    towerInfoModal.classList.add('encourage-tower');
  } else if (tower.type.name === 'ğŸ’°é‡‘å¹£å¡”') {
    infoTitle.classList.add('gold-tower');
    infoContent.classList.add('gold-tower');
    towerInfoModal.classList.add('gold-tower');
  } else if (tower.type.name === 'âœŒï¸å¿…å‹å¡”') {
    infoTitle.classList.add('win-tower');
    infoContent.classList.add('win-tower');
    towerInfoModal.classList.add('win-tower');
  }

  // æŒçºŒæ›´æ–°å‡½å¼ï¼Œè®“å€’æ•¸è¨ˆæ™‚å¯¦æ™‚æ›´æ–°
  function updateInfo() {
      if (selectedTower !== tower || towerInfoModal.style.display === 'none') return;
      const info = tower.getInfo();
      infoTitle.innerHTML = `${info.name} è©³ç´°è³‡è¨Š`;
      infoContent.innerHTML = `
        <p><strong>æ˜Ÿç´š:</strong> ${info.emoji.repeat(info.stars)}</p>
        <p><strong>å¤§å°:</strong> ${info.size}</p>
        <p><strong>æ”»æ“ŠåŠ›:</strong> ${info.dmg}</p>
        <p><strong>å°„ç¨‹:</strong> ${info.range}</p>
        <p><strong>æ”»é€Ÿ:</strong> ${info.attackSpeed}</p>
        ${info.splash > 0 ? `<p><strong>æ¿ºå°„:</strong> ${info.splash.toFixed(0)}</p>` : ''}
        <p><strong>å·²å­¸æŠ€èƒ½:</strong> ${info.skills}</p>
      `;
      requestAnimationFrame(updateInfo);
  }

  towerInfoModal.style.display = 'block';
  updateInfo();
}
function closeTowerInfo() {
  towerInfoModal.style.display = 'none';
  selectedTower = null;
}

// --- éŠæˆ²é€Ÿåº¦ ---
function toggleSpeed() {
  initAudio();
  gameSpeed = gameSpeed === 1 ? 3 : 1;
  speedBtn.textContent = gameSpeed + 'x';
  speedBtn.style.background = gameSpeed === 3 ? 'linear-gradient(145deg, #ff6666, #ff4444)' : 'linear-gradient(145deg, #ff4444, #cc3333)';
}

// --- æŠ€èƒ½å­¸ç¿’ ---
function openSkill() {
  if (wave < 2) return;
  
  const uniqueTowerTypesOnBoard = [...new Set(towers.map(t => t.type))];
  const typesWithAvailableSkills = uniqueTowerTypesOnBoard.filter(type => {
      if (['â¤ï¸ç”Ÿå‘½å¡”', 'ğŸ‘é¼“å‹µå¡”', 'ğŸ’°é‡‘å¹£å¡”', 'âœŒï¸å¿…å‹å¡”'].includes(type.name)) {
          const learned = learnedSkillsRegistry.get(type.name) || new Set();
          return learned.size < type.skills.length;
      }
      const learnedSkills = learnedSkillsRegistry.get(type.name) || new Set();
      return learnedSkills.size < type.skills.length;
  });
  if (typesWithAvailableSkills.length === 0) { console.log("æ‰€æœ‰åœ¨å ´ä¸Šçš„å¡”éƒ½å·²å­¸æ»¿æŠ€èƒ½ã€‚"); return; }
  
  const cost = calculateSkillCost(skillIndex);
  if (gold < cost) return;

  skillPausedSpeed = gameSpeed;
  gameSpeed = 0;
  
  const randomTowerType = typesWithAvailableSkills[Math.floor(Math.random() * typesWithAvailableSkills.length)];
  const numOptions = Math.min(3, randomTowerType.skills.length);
  document.getElementById('skillTitle').innerHTML = `ã€${randomTowerType.name}ã€‘<br>${numOptions}é¸ä¸€æŠ€èƒ½ ($${cost})`;
  
  const skillOptions = document.getElementById('skillOptions');
  skillOptions.innerHTML = '';
  
  const learnedSkills = learnedSkillsRegistry.get(randomTowerType.name) || new Set();
  const availableSkills = randomTowerType.skills.filter(s => !learnedSkills.has(s.name));
  
  if (availableSkills.length === 0) { closeSkill(); return; }

  let skillsToShow = [...availableSkills].sort(() => 0.5 - Math.random()).slice(0, numOptions);
  skillsToShow.forEach((skill) => {
    const div = document.createElement('div');
    div.className = 'skillOpt';
    div.innerHTML = `<strong>${skill.name}</strong><br><small>${skill.desc}</small>`;
    div.onclick = () => selectSkill(skill, randomTowerType);
    skillOptions.appendChild(div);
  });
  skillModal.style.display = 'block';
}
function selectSkill(skill, type) {
  const cost = calculateSkillCost(skillIndex);
  if (gold < cost) { closeSkill(); return; }
  
  gold -= cost; skillIndex++; 
  
  if (skill.effect === 'grant_gold') {
      gold += skill.value;
  }
  if (skill.effect === 'free_castle') {
      freeCastleCharges = (freeCastleCharges || 0) + skill.value;
  }
  
  // å¿…å‹å¡”æŠ€èƒ½å¯¦ç¾
  if (skill.effect === 'black_hole') {
      const cx = gameWidth / 2;
      const cy = gameHeight / 2;
      blackHoles.push(new BlackHole(cx, cy, skill.value));
  }
  if (skill.effect === 'instant_3_star') {
      victoryInstant3StarCharges += skill.value;
  }
  
  // --- ä¿®æ­£ï¼šç¥ä¹‹åŠ å†• (All 5 Star) é‚è¼¯ ---
  if (skill.effect === 'all_5_star') {
      towers.forEach(t => {
          if (t.type.name !== 'âœŒï¸å¿…å‹å¡”') {
              t.stars = 5;
              
              // é‡æ–°è¨ˆç®—æ”»æ“ŠåŠ› (åŸºç¤ * 2^(æ˜Ÿç´š-1))
              const dmgMultiplier = Math.pow(2, t.stars - 1);
              t.dmg = t.type.baseDmg * dmgMultiplier;
              
              // ç‰¹æ®Šï¼šç”Ÿå‘½å¡”çš„æ”»é€Ÿ(æ²»ç™‚é€Ÿåº¦)éš¨æ˜Ÿç´šè®ŠåŒ–ï¼Œéœ€æ›´æ–°
              if (t.type.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
                  t.rate = 10000 + (t.stars - 1) * 5000;
              }
              
              // é‡æ–°æ‡‰ç”¨å·²å­¸ç¿’çš„ã€æœƒå½±éŸ¿åŸºç¤æ•¸å€¼çš„æŠ€èƒ½ (å¦‚: é‡å‹ç‚®å½ˆ +100% dmg)
              t.appliedSkills.forEach(s => {
                   if (s.effect === 'dmg') t.dmg *= s.value;
              });
          }
      });
  }
  
  if (skill.effect === 'skip_to_wave_10') {
      wave = 9; 
      enemies.forEach(e => e.hp = 0); 
      bossHpOverride = 12345; 
      waveEnemies = waveSpawned; 
      enemies = [];
  }

  if (skill.effect === 'new_slot_random_tower') {
      addNewSlot();
      setTimeout(() => {
          const emptyNormalSlots = slots.map((s, i) => ({s, i}))
              .filter(item => !item.s.isSpecial && !towers.some(t => t.slot === item.i))
              .map(item => item.i);
              
          if (emptyNormalSlots.length > 0) {
              const slotIdx = emptyNormalSlots[emptyNormalSlots.length - 1]; 
              let randomTypeFromDeck;
              if (window.selectedDeckTypes && window.selectedDeckTypes.length > 0) {
                  randomTypeFromDeck = window.selectedDeckTypes[Math.floor(Math.random() * window.selectedDeckTypes.length)];
              } else {
                  randomTypeFromDeck = window.towerTypes[Math.floor(Math.random() * window.towerTypes.length)];
              }
              towers.push(new Tower(slotIdx, randomTypeFromDeck, 4)); 
          }
      }, 100);
  }
  
  if (skill.effect === 'special_slot') {
      const newSlotIndex = addNewSlot(); 
      if (newSlotIndex !== -1) {
          slots[newSlotIndex].isSpecial = true; 
      }
  }
  if (skill.effect === 'inspire_slot') {
      nextInspireTime = gameTime;
  }

  if (skill.effect === 'king_max_hp') {
      maxHp = skill.value; 
      hp = Math.min(hp, maxHp); 
  }
  if (skill.effect === 'king_regen') {
      kingRegenPerWave += skill.value;
  }
  if (skill.effect === 'enemy_hp_debuff') {
      enemyHpDebuff = skill.value; 
  }
  if (skill.effect === 'king_shield') {
      hasKingShield = true;
      kingShieldCharges = skill.value; 
  }

  if (skill.effect === 'fixed_cost') {
      fixedCostActive = true; 
  }
  if (skill.effect === 'multiply_gold') {
      gold *= skill.value; 
  }
  
  updateUI(); 
  
  if (!learnedSkillsRegistry.has(type.name)) learnedSkillsRegistry.set(type.name, new Set());
  learnedSkillsRegistry.get(type.name).add(skill.name);
  
  if (skill.effect !== 'super_charge' && skill.effect !== 'black_hole' && skill.effect !== 'skip_to_wave_10') {
      towers.filter(t => t.type === type).forEach(t => {
        t.applySkill(skill);
      });
  }
  
  if (selectedTower) showTowerInfo(selectedTower);
  closeSkill();
}
function closeSkill() { 
    skillModal.style.display = 'none';
    gameSpeed = skillPausedSpeed;
}

// --- åŸå ¡æŠ€èƒ½ ---
function openCastle() {
  const cost = getCastleCost(); 
  if (gold < cost && cost > 0) return; 
  
  const costText = cost === 0 ? "å…è²»" : `$${cost}`; 
  
  document.getElementById('castleTitle').innerHTML = `åŸå ¡æŠ€èƒ½ (${costText})<br>äºŒé¸ä¸€`; 
  const castleOptions = document.getElementById('castleOptions');
  castleOptions.innerHTML = '';
  const skills = [...castleSkills].sort(() => 0.5 - Math.random());
  skills.slice(0, 2).forEach((skill) => {
    const div = document.createElement('div');
    div.className = 'castleOpt';
    div.innerHTML = `<strong>${skill.name}</strong><br><small>${skill.desc}</small>`;
    div.onclick = () => selectCastleSkill(skill);
    castleOptions.appendChild(div);
  });
  castleModal.style.display = 'block';
}
function selectCastleSkill(skill) {
  const cost = getCastleCost(); 
  
  if (cost === 0) {
      freeCastleCharges--; 
  } else {
      if (gold < cost) { closeCastle(); return; }
      gold -= cost;

      if (window.castleCostTacticApplied) {
          window.castleCostTacticApplied = false;
      }
  }
  
  updateUI(); 
  
  switch (skill.effect) {
    case 1: enemies.forEach(e => { e.rewindUntil = gameTime + 1000; }); break;
    case 2: 
      let nonBossEnemies = enemies.filter(e => e.hp > 0 && !e.type.isBoss);
      for (let i = 0; i < 2 && nonBossEnemies.length > 0; i++) {
        let idx = Math.floor(Math.random() * nonBossEnemies.length);
        let e = nonBossEnemies[idx];
        e.hp = 0;
        onEnemyDeath(e); 
        nonBossEnemies.splice(idx, 1);
      }
      updateUI();
      break;
    case 3: monsterStunTime = gameTime + 3000; break;
    case 4: hp = Math.min(maxHp, hp + 4); updateUI(); break;
    case 5: nextMonstersHalfHp = 5; break;
  }
  addNewSlot(); 
  closeCastle();
}
function closeCastle() { castleModal.style.display = 'none'; }

// --- è¨­ç½®é¸å–® ---
function openSettings() {
  previousGameSpeed = gameSpeed;
  gameSpeed = 0; 
  settingsModal.style.display = 'block';
}

function closeSettings() {
  settingsModal.style.display = 'none';
  gameSpeed = previousGameSpeed; 
}

// --- UI æ›´æ–° ---
function updateCosts() {
  const placeCost = calculatePlaceCost(placeIndex);
  placeCostBubble.textContent = `$${placeCost}`;
  placeBtn.style.opacity = gold >= placeCost ? 1 : 0.5;
  
  const skillCost = calculateSkillCost(skillIndex);
  skillCostBubble.textContent = `$${skillCost}`;
  
  if (wave < 2) {
      skillBtn.style.opacity = 0.3;
      skillCostBubble.style.display = 'none';
  } else {
      skillBtn.style.opacity = gold >= skillCost ? 1 : 0.5;
      skillCostBubble.style.display = 'block';
  }

  const castleCost = getCastleCost(); 
  castleCostBubble.textContent = castleCost === 0 ? "å…è²»" : `$${castleCost}`; 
  castleBtn.style.opacity = (gold >= castleCost || castleCost === 0) ? 1 : 0.5; 
}
function updateUI() { 
  ui.gold.textContent = gold; 
  ui.hp.textContent = `${hp}/${maxHp}`; 
  updateCosts();
}

// --- éŠæˆ²çµæŸ/é‡ç½® ---
function gameOver(isVictory = false) {
  gameSpeed = 0; 
  infoModal.classList.remove('victory');
  const infoTitle = document.getElementById('infoTitle');
  const infoText = document.getElementById('infoText');
  const infoBtn = document.querySelector('#info button');

  if (isVictory) {
      infoModal.classList.add('victory');
      infoTitle.textContent = 'ğŸ† å‹åˆ©ï¼å¡”é˜²ç‹åœ‹å¾—æ•‘äº†ï¼';
      infoText.textContent = `æ­å–œæ‚¨æ“Šæ•—äº†çµ‚æ¥µå¤§ Bossï¼\næ‚¨ä»¥ ${hp} é»åœ‹ç‹è¡€é‡å’Œ${window.activeTactic ? window.activeTactic.name : 'æœªçŸ¥æˆ°è¡“'}å®Œæˆäº†éŠæˆ²ã€‚`;
      infoBtn.textContent = 'å¤ªæ£’äº†ï¼è¿”å›ä¸»é¸å–®';
  } else {
      infoTitle.textContent = 'åœ‹ç‹é™£äº¡ï¼';
      infoText.textContent = `è«‹å˜—è©¦ç”¨âœŒï¸å¿…å‹å¡”ï¼Œå–å¾—å‹åˆ©å§ï¼ï¼`;
      infoBtn.textContent = 'è¿”å›ä¸»é¸å–®';
  }
  document.getElementById('info').style.display = 'block';
}
function closeInfo() {
  document.getElementById('info').style.display = 'none';
  resetGame(); 
}
function resetGame() {
  if (gameLoopId) {
      cancelAnimationFrame(gameLoopId);
      gameLoopId = null;
  }

  gameSpeed = 1; 
  speedBtn.textContent = '1x';
  speedBtn.style.background = 'linear-gradient(145deg, #ff4444, #cc3333)';

  gold = 5001; wave = 1; hp = 20; maxHp = 20; 
  towers = []; enemies = []; projectiles = [];
  placeIndex = 0; skillIndex = 0; nextMonstersHalfHp = 0;
  monsterStunTime = 0; monsterRewindTime = 0;
  selectedTower = null;
  potentialDrag = null; draggingTower = null; dragging = false;
  lastMinionSpawn = 0; gameTime = 0; lastRealTime = 0;
  lastLightningSpeedCheck = 0; lightningSpeedBuffActiveUntil = 0;
  freeCastleCharges = 0; 
  
  nextBossStunTime = 0; 
  towersStunnedUntil = 0; 
  
  kingRegenPerWave = 0;
  enemyHpDebuff = 0;
  kingShieldCharges = 0;
  hasKingShield = false;
  
  inspiredBuffs = [];
  nextInspireTime = 0;
  globalBuffs = { atkBuff: 0, rangeBuff: 0, splashBuff: 0, speedBuff1Star: 0 };

  fixedCostActive = false; 

  // é‡ç½®è®Šæ•¸
  victoryInstant3StarCharges = 0;
  blackHoles = [];
  bossHpOverride = 0;

  guaranteedFirstTowerType = null;
  castleCostTacticApplied = false;

  slots = []; 
  settingsModal.style.display = 'none'; 
  
  learnedSkillsRegistry.clear(); 
  
  window.activeTactic = null;
  window.tacticCannonKills = 0;
  window.selectedDeckTypes = [];
  
  document.getElementById('game').style.display = 'none';
  document.getElementById('mainMenu').style.display = 'flex';
  
  if (window.resetMenuUI) window.resetMenuUI();
}

function onEnemyDeath(enemy) {
    // ç°¡å–®åŠ éŒ¢ (æ³¨æ„ï¼šå¹½éˆé‡‘å¹£ç‚ºè² ï¼Œæ‰€ä»¥æœƒæ‰£éŒ¢)
    gold += enemy.gold; 

    // è™•ç†å¾©æ´» (éª·é« -> å°éª·é«)
    if (enemy.type.revivesTo !== undefined) {
        const newTypeIdx = enemy.type.revivesTo;
        const newEnemy = new Enemy(newTypeIdx);
        newEnemy.x = enemy.x;
        newEnemy.y = enemy.y;
        newEnemy.targetX = enemy.targetX;
        newEnemy.targetY = enemy.targetY;
        enemies.push(newEnemy);
    }
}

// --- Enemy é¡åˆ¥ ---
class Enemy {
  constructor(typeIdx) {
    const type = enemyTypes[typeIdx];
    this.type = type;
    
    let baseHp;
    if (type.emoji === 'ğŸ‘»') {
        baseHp = 1000;
    } 
    else if (type.isBoss) {
        baseHp = type.hp; 
        if (bossHpOverride > 0) {
            baseHp = bossHpOverride;
        }
    } else {
        baseHp = type.hp * Math.pow(1.5, wave - 1);
    }
    
    baseHp *= (1.0 - enemyHpDebuff);

    this.isHalfHp = false; 
    if (nextMonstersHalfHp > 0 && !type.isBoss && type.emoji !== 'ğŸ‘»') { 
      baseHp = Math.floor(baseHp / 2);
      nextMonstersHalfHp--; 
      this.isHalfHp = true; 
    }
    
    this.maxHp = Math.ceil(baseHp);
    this.hp = this.maxHp; 
    
    this.speed = type.speed; this.gold = type.gold; this.emoji = type.emoji;
    
    if (type.emoji === 'ğŸ¤–' || type.emoji === 'ğŸ‘»') {
        this.x = (gameWidth * 0.2) + Math.random() * (gameWidth * 0.6);
        this.y = (gameHeight * 0.35) + Math.random() * (gameHeight * 0.2);
        this.speed = 0; 
    } else {
        this.x = Math.random() * gameWidth; 
        this.y = 0 - (Math.random() * TILE * 2); 
    }
    
    this.targetX = gameWidth * 0.5 + (Math.random() - 0.5) * gameWidth * 0.35;
    this.targetY = gameHeight * BASELINE_Y;
    this.stunnedUntil = 0; 
    this.rewindUntil = 0; 
    // (Removed tauntStun logic) 
    this.slowUntil = 0; this.slowFactor = 1;
    this.burnDamage = 0; this.burnExpiresAt = 0; this.lastBurnTick = gameTime; 
    this.lastHealTick = gameTime; 
    // (Removed hasSplit)

    this.lastRangedAttack = gameTime;
    this.hasVoidDebuff = false; // ç„¡æ³•è¢«æ²»ç™‚æ¨™è¨˜
  }

  applySlow(factor, duration = 1000) { 
      this.slowFactor = 1.0 - factor; 
      this.slowUntil = gameTime + duration;
  }
  applyBurn(dmgPerTick, duration = 5000) { 
      if (dmgPerTick > this.burnDamage) this.burnDamage = dmgPerTick; 
      this.burnExpiresAt = gameTime + duration;
      this.lastBurnTick = gameTime; 
  }

  update() {
    const now = gameTime;

    if (this.type.isRanged && this.hp > 0) {
        if (now - this.lastRangedAttack >= 3000) { // 3ç§’
            this.lastRangedAttack = now;
            this.shootKing();
        }
    }

    // (Removed tauntStun logic block)

    if (!this.type) { console.error("Bugged enemy", this); this.hp = 0; return true; }

    if (this.type.isHealer) {
        if (now - this.lastHealTick > 500) { 
            enemies.forEach(e => {
                if (e !== this && e.hp > 0 && e.hp < e.maxHp && !e.hasVoidDebuff) {
                    e.hp = Math.min(e.maxHp, e.hp + 1);
                }
            });
            this.lastHealTick = now;
        }
    }

    if (this.burnExpiresAt > now) {
        if (now - this.lastBurnTick > 200) { 
            this.hp -= this.burnDamage; 
            this.lastBurnTick = now;
            if (this.hp <= 0) {
                onEnemyDeath(this); 
                return true; 
            }
        }
    } else {
        this.burnDamage = 0; 
    }
    
    if (this.stunnedUntil > now || monsterStunTime > now) return false; 

    if (this.speed > 0 && this.rewindUntil > now) {
        const dx = this.targetX - this.x; const dy = this.targetY - this.y;
        const dsum = Math.hypot(dx, dy);
        if (dsum > 0) { 
            const baseRewindSpeed = this.type.isBoss ? 1 : 5; 
            const rewindSpeed = baseRewindSpeed * gameSpeed; 
            this.x -= (dx / dsum) * rewindSpeed;
            this.y -= (dy / dsum) * rewindSpeed;
        }
        return false; 
    }

    let currentSpeed = this.speed; 
    if (this.slowUntil > now) currentSpeed *= this.slowFactor;
    else this.slowFactor = 1; 
    
    if (currentSpeed <= 0) return false;

    const dx = this.targetX - this.x; const dy = this.targetY - this.y;
    const dsum = Math.hypot(dx, dy);
    
    if (dsum < 4) {
        if (this.type.isBoss) {
            gameOver(false);
            return true;
        } else {
            if (kingShieldCharges > 0 && !this.type.isBoss) {
                kingShieldCharges--; 
            } else {
                if (this.type.emoji === 'ğŸ‘¹') {
                    hp = Math.max(0, hp - 2); 
                } else {
                    hp--; 
                }
            }

            updateUI();
            if (hp <= 0) gameOver();
            return true; 
        }
    }
    
    const step = currentSpeed * gameSpeed; 
    this.x += (dx / dsum) * step; this.y += (dy / dsum) * step;
    return false; 
  }

  shootKing() {
      ctx.save();
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      const castleBaseY = gameHeight * BASELINE_Y;
      const castleCenterX = gameWidth / 2;
      ctx.lineTo(castleCenterX, castleBaseY);
      ctx.stroke();
      ctx.restore();
      
      hp = Math.max(0, hp - 1);
      updateUI();
      if (hp <= 0) gameOver();
  }
  
  draw() {
    if (this.isHalfHp) {
        ctx.save(); ctx.fillStyle = 'rgba(255, 105, 180, 0.4)'; 
        ctx.beginPath(); ctx.arc(this.x, this.y, TILE * 0.6, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }
    if (this.burnExpiresAt > gameTime) {
        ctx.save(); ctx.fillStyle = 'rgba(255, 100, 0, 0.3)'; 
        ctx.beginPath(); ctx.arc(this.x, this.y, TILE * 0.55, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }

    if (this.rewindUntil > gameTime) {
        ctx.save(); 
        ctx.fillStyle = 'rgba(135, 206, 250, 0.4)'; 
        ctx.beginPath(); ctx.arc(this.x, this.y, TILE * 0.7, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }
    
    if (enemyHpDebuff > 0 && this.hp === this.maxHp) {
        ctx.save(); 
        ctx.fillStyle = 'rgba(128, 0, 128, 0.3)'; 
        ctx.beginPath(); ctx.arc(this.x, this.y, TILE * 0.65, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }

    if (this.hasVoidDebuff) {
        ctx.save();
        ctx.strokeStyle = '#8A2BE2'; // ç´«è‰²é‚Šæ¡†
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(this.x, this.y, TILE * 0.6, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();
    }

    let fontSize = TILE * 0.85;
    if (this.type.isBoss) fontSize = TILE * (this.type.isFinalBoss ? 1.5 : 1.2); 

    ctx.font = `${fontSize}px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(this.emoji, this.x, this.y);
    
    const barW = TILE * (this.type.isBoss ? 1.5 : 1.0); const barH = 6; 
    const barY = this.y - (TILE / 2) - 12; 
    ctx.fillStyle = '#333'; ctx.fillRect(this.x - barW / 2, barY, barW, barH);
    const hpPercent = this.hp / this.maxHp;
    ctx.fillStyle = hpPercent > 0.5 ? '#4CAF50' : (hpPercent > 0.2 ? '#FFC107' : '#F44336'); 
    ctx.fillRect(this.x - barW / 2, barY, barW * hpPercent, barH);
    ctx.font = `12px Arial`; ctx.fillStyle = '#FFFFFF';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(`${Math.ceil(this.hp)}/${this.maxHp}`, this.x, barY - 8); 
  }
}

// --- Projectile é¡åˆ¥ ---
class Projectile {
  constructor(sx, sy, target, dmg, emoji, color, splash, isCrit, skills, stars, confidenceDmg = 0) { 
    this.x = sx; this.y = sy; this.target = target; 
    this.dmg = dmg; this.emoji = emoji; this.color = color;
    this.splash = splash; this.isCrit = isCrit;
    this.speed = 15; this.hit = false;
    this.skills = skills || []; 
    this.towerStars = stars || 1; 
    this.confidenceDmg = confidenceDmg; 
  }

  update() {
    if (this.hit || !this.target || this.target.hp <= 0) return true; 

    const dx = this.target.x - this.x; const dy = this.target.y - this.y;
    const dist = Math.hypot(dx, dy);

    if (dist <= this.speed * gameSpeed) {
      this.hitTarget(); return true; 
    }
    const moveX = (dx / dist) * this.speed * gameSpeed;
    const moveY = (dy / dist) * this.speed * gameSpeed;
    this.x += moveX; this.y += moveY;
    return false; 
  }

  hitTarget() {
    if (this.hit || !this.target) return; 
    this.hit = true;
    
    if (this.target.hp <= 0 && this.dmg >= 0) return; 

    if (this.target.hasVoidDebuff && this.dmg < 0) {
        // æ²»ç™‚ç„¡æ•ˆ
        return;
    }

    if (this.confidenceDmg > 0) {
        this.target.hp -= this.confidenceDmg;
    } else {
        let bonusDmg = 0;
        const focusFireSkill = this.skills.find(s => s.effect === 'focus_fire');
        if (focusFireSkill) bonusDmg = focusFireSkill.value;
        
        let finalAppliedDmg = this.dmg + bonusDmg;
        if (this.target.type.emoji === 'ğŸ²') {
            finalAppliedDmg *= 0.95; 
        }
        this.target.hp -= finalAppliedDmg;
        
        if (finalAppliedDmg < 0) {
            this.target.hp = Math.min(this.target.hp, this.target.maxHp);
        }
    }
    
    const stunSkill = this.skills.find(s => s.effect === 'stun');
    if (stunSkill) this.target.stunnedUntil = gameTime + stunSkill.value;

    const slowSkill = this.skills.find(s => s.effect === 'slow');
    if (slowSkill) this.target.applySlow(Math.min(slowSkill.value, 0.9), 1000); 

    const burnSkill = this.skills.find(s => s.effect === 'burn');
    if (burnSkill) this.target.applyBurn(this.dmg * burnSkill.value, 5000); 

    if (this.splash > 0) {
      const splashRadius = this.splash * TILE;
      for (const e of enemies) {
        if (e === this.target || e.hp <= 0) continue; 
        if (Math.hypot(this.x - e.x, this.y - e.y) < splashRadius) {
          
          let splashDmg = this.dmg * 0.65;
          if (e.type.emoji === 'ğŸ²') {
              splashDmg *= 0.95; 
          }
          e.hp -= splashDmg; 

          if (e.hp <= 0) {
              onEnemyDeath(e); 
          }
          if (stunSkill) e.stunnedUntil = gameTime + stunSkill.value;
        }
      }
    }
    
    const chainSkill = this.skills.find(s => s.effect === 'chain');
    if (chainSkill) {
        const targetTypeEmoji = this.target.type.emoji;
        const chainDamage = this.dmg * chainSkill.value; 
        let chainCount = 0; const maxChain = 6;
        for (const e of enemies) {
            if (e === this.target || e.hp <= 0 || e.type.emoji !== targetTypeEmoji || chainCount >= maxChain) continue;
            if (Math.hypot(this.x - e.x, this.y - e.y) > TILE * 6) continue; 
            
            let finalChainDmg = chainDamage;
            if (e.type.emoji === 'ğŸ²') {
                finalChainDmg *= 0.95; 
            }
            e.hp -= finalChainDmg; 
            
            if (e.hp <= 0) {
              onEnemyDeath(e); 
            }
            chainCount++;
        }
    }

    if (window.activeTactic && window.activeTactic.id === 'archer_boss' && this.emoji === 'ğŸ¹' && this.towerStars === 1 && this.target.type.isBoss) {
        gold += 654321;
    }

    if (this.target.hp <= 0) {
        
        onEnemyDeath(this.target);

        if (window.activeTactic && window.activeTactic.id === 'cannon_kill' && this.emoji === 'ğŸ’£' && this.towerStars === 1) {
            window.tacticCannonKills++; 
            towers.forEach(t => {
                if (t.type.name === 'ğŸ’£ç‚®å¡”' && t.stars === 1) {
                    const baseDmg = t.type.baseDmg; 
                    const dmgMultiplier = Math.pow(2, t.stars - 1); 
                    
                    let newDmg = baseDmg * dmgMultiplier;
                    
                    const buff = (1 + (window.tacticCannonKills * 0.03)); 
                    newDmg *= buff;

                    const heavyShells = t.appliedSkills.find(s => s.effect === 'dmg');
                    if (heavyShells) {
                        newDmg *= heavyShells.value; 
                    }

                    t.dmg = newDmg;
                }
            });
        }
    }
    
    updateUI();
  }

  draw() {
    ctx.fillStyle = this.color;
    let fontSize = 28;
    if (this.emoji === 'ğŸ¹' || this.emoji === 'âš¡') fontSize = 24; 
    if (this.emoji === 'ğŸ’£') fontSize = 32;
    if (this.emoji === 'â¤ï¸' || this.emoji === 'ğŸ‘' || this.emoji === 'ğŸ’°') fontSize = 30; 
    if (this.emoji === 'âœŒï¸') fontSize = 30;

    if (this.isCrit) {
        ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 10; fontSize *= 1.2;
    }
    
    if (this.emoji === 'â¤ï¸') {
        ctx.shadowColor = '#FFFFFF'; ctx.shadowBlur = 8;
    }

    ctx.font = `${fontSize}px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(this.emoji, this.x, this.y);
    if (this.isCrit || this.emoji === 'â¤ï¸') ctx.shadowBlur = 0; 
  }
}

// --- ç•«é¢ä½ˆå±€å’Œèª¿æ•´ ---
function positionBottomControls(wallY, wallHeight) {
  bottomControls.style.top = `${wallY + 14}px`;
  bottomControls.style.height = `${Math.max(68, wallHeight - 20)}px`;
  positionBubbleBelow(skillBtn, skillCostBubble, 8);
  positionBubbleBelow(placeBtn, placeCostBubble, 8);
  positionBubbleBelow(castleBtn, castleCostBubble, 8);
}
function positionBubbleBelow(buttonEl, bubbleEl, offset = 6) {
  const contRect = container.getBoundingClientRect();
  const btnRect = buttonEl.getBoundingClientRect();
  if (contRect.width === 0 || btnRect.width === 0) return; 
  const x = btnRect.left - contRect.left + btnRect.width / 2;
  const y = btnRect.bottom - contRect.top + offset;
  bubbleEl.style.display = 'block';
  bubbleEl.style.left = `${x - bubbleEl.offsetWidth / 2}px`;
  bubbleEl.style.top = `${y}px`;
}
function resize() {
  gameWidth = canvas.width = container.clientWidth;
  gameHeight = canvas.height = container.clientHeight;
  const baseCols = 7; 
  TILE = gameWidth / baseCols; 
  cols = baseCols;
  rows = Math.floor(gameHeight / TILE);
  castleY = Math.max(0, Math.floor(rows * BASELINE_Y) - 1);
  
  if (slots.length === 0) initSlots();
  
  towers.forEach(t => {
    if (['â¤ï¸ç”Ÿå‘½å¡”','ğŸ‘é¼“å‹µå¡”','ğŸ’°é‡‘å¹£å¡”'].includes(t.type.name)) {
      t.range = t.baseRangeTiles * TILE;
    } else {
      t.range = t.baseRangeTiles * TILE;
    }
    
    if (t.isConfidenceActive) {
        t.range = 2 * TILE;
    } else {
        t.appliedSkills.forEach(skill => {
            if (skill.effect === 'range' && !['â¤ï¸ç”Ÿå‘½å¡”','ğŸ‘é¼“å‹µå¡”','ğŸ’°é‡‘å¹£å¡”'].includes(t.type.name)) { 
              t.range = t.baseRangeTiles * TILE; t.range *= skill.value; 
            } 
            if (skill.effect === 'range_add' && !['â¤ï¸ç”Ÿå‘½å¡”','ğŸ‘é¼“å‹µå¡”','ğŸ’°é‡‘å¹£å¡”'].includes(t.type.name)) {
              t.range += skill.value * TILE; 
            }
        });
    }
  });
  
  const currentSlots = getCastleSlots();
  const slotPixelY = currentSlots.length > 0 ? currentSlots[0].y * TILE : (gameHeight * BASELINE_Y);
  positionBottomControls(slotPixelY, gameHeight - slotPixelY);
}
window.addEventListener('resize', () => {
  resize();
  requestAnimationFrame(() => {
    updateCosts(); 
    const currentSlots = getCastleSlots();
    const slotPixelY = currentSlots.length > 0 ? currentSlots[0].y * TILE : (gameHeight * BASELINE_Y);
    positionBottomControls(slotPixelY, gameHeight - slotPixelY);
  });
});

// --- éŠæˆ²ä¸»å¾ªç’° ---
function loop(now) {
  if (gameSpeed === 0) { 
      gameLoopId = requestAnimationFrame(loop); 
      return;
  }
  if (!lastRealTime) lastRealTime = now;
  const realDt = now - lastRealTime; 
  gameTime += realDt * gameSpeed; 
  lastRealTime = now;

  {
      let atkBuff = 0;
      let rangeBuff = 0.0;
      let splashBuff = 0;
      let speedBuff1Star = 0; // æ–°å¢1æ˜Ÿæ”»é€ŸBuff

      const allEncourageTowers = towers.filter(t => t && t.type.name === 'ğŸ‘é¼“å‹µå¡”');
      const encourageCount = allEncourageTowers.length;

      if (encourageCount > 0) { 
          let hasLearnedAtkBuff = allEncourageTowers.some(t => t.appliedSkills.some(s => s.effect === 'global_atk_buff'));
          // "è¦–é‡æ“´å±•" é‡è£½å¾Œè®Šç‚º global_speed_buff_1star
          let hasLearnedSpeedBuff = allEncourageTowers.some(t => t.appliedSkills.some(s => s.effect === 'global_speed_buff_1star'));
          
          if (hasLearnedAtkBuff) atkBuff = encourageCount * 20;
          // æ¯å€‹é¼“å‹µå¡” +80% (0.8)
          if (hasLearnedSpeedBuff) speedBuff1Star = encourageCount * 0.8;
      }
      
      if (window.activeTactic && window.activeTactic.id === 'cheer_splash') {
          const oneStarEncourageTowers = allEncourageTowers.filter(t => t.stars === 1).length;
          // æˆ°è¡“åŠ å¼·ï¼šé™¤äº†Splashå¤–ï¼Œä¹ŸåŠ Range
          splashBuff += oneStarEncourageTowers * 1;
          rangeBuff += oneStarEncourageTowers * 1 * TILE;
      }
      globalBuffs = { atkBuff, rangeBuff, splashBuff, speedBuff1Star };
  }

  // éš¨æ©Ÿé¼“èˆé‚è¼¯ (é‡è£½ç‰ˆ)
  // æ¯15ç§’ï¼Œé¼“èˆ2å€‹éé¼“å‹µå¡”çš„å¡”æ§½ï¼ŒæŒçºŒ20ç§’
  if (gameTime > nextInspireTime) {
      nextInspireTime = gameTime + inspireInterval; 
      
      const hasLearnedInspire = towers.some(t => 
          t && t.type.name === 'ğŸ‘é¼“å‹µå¡”' && 
          t.appliedSkills.some(s => s.effect === 'inspire_slot')
      );

      if (hasLearnedInspire && slots.length > 0) {
          // æ‰¾å‡ºæ‰€æœ‰éé¼“å‹µå¡”çš„å¡”æ§½ (ç›®å‰æœ‰å¡”ä¸”ä¸æ˜¯é¼“å‹µå¡”)
          const candidateSlots = towers
              .filter(t => t.type.name !== 'ğŸ‘é¼“å‹µå¡”')
              .map(t => t.slot);
          
          // å»é‡
          const uniqueCandidates = [...new Set(candidateSlots)];
          
          let chosen = [];
          
          // å¦‚æœæœ‰éé¼“å‹µå¡”ï¼Œå„ªå…ˆå¾ä¸­é¸ 2 å€‹
          if (uniqueCandidates.length > 0) {
               // éš¨æ©Ÿæ‰“äº‚
               const shuffled = uniqueCandidates.sort(() => 0.5 - Math.random());
               chosen = shuffled.slice(0, 2);
          } 
          // å¦‚æœå ´ä¸Šå…¨æ˜¯é¼“å‹µå¡”æˆ–æ²’æœ‰å¡” (æ¥µç«¯æƒ…æ³)ï¼Œéš¨æ©Ÿé¸ç©ºæ§½ä½? 
          // ä¾ç…§æè¿°"éé¼“å‹µå¡”çš„å¡”æ§½"ï¼Œæˆ‘å€‘é€™è£¡åªé¸å·²ç¶“æœ‰å¡”çš„ã€‚è‹¥ä¸è¶³2å€‹ï¼Œå°±åªé¼“èˆé‚£1å€‹ã€‚

          chosen.forEach(slotIdx => {
              // ç§»é™¤è©²æ§½ä½èˆŠçš„ buff (å¦‚æœå­˜åœ¨)ï¼Œç¢ºä¿æ™‚é–“é‡ç½®
              inspiredBuffs = inspiredBuffs.filter(b => b.slot !== slotIdx);
              inspiredBuffs.push({
                  slot: slotIdx,
                  expire: gameTime + inspireDuration
              });
          });
      }
  }
  // æ¸…ç†éæœŸ Buff
  inspiredBuffs = inspiredBuffs.filter(b => b.expire > gameTime);

  const isBossWave = (wave === 5 || wave === 10) && enemies.some(e => e.type.isBoss);
  if (isBossWave) {
      if (nextBossStunTime === 0) {
          nextBossStunTime = gameTime + bossStunInterval;
          towersStunnedUntil = 0; 
      }
      if (gameTime >= nextBossStunTime) {
          towersStunnedUntil = gameTime + bossStunDuration;
          nextBossStunTime = gameTime + bossStunInterval; 
      }
  } else {
      nextBossStunTime = 0;
      towersStunnedUntil = 0;
  }

  const lightningType = window.towerTypes.find(t => t.name === 'âš¡é›·å¡”');
  const hasSuperCharge = learnedSkillsRegistry.has('âš¡é›·å¡”') && learnedSkillsRegistry.get('âš¡é›·å¡”').has('è¶…é€Ÿæ”¾é›»');
  if (hasSuperCharge && gameTime - lastLightningSpeedCheck >= 7000) { 
      lastLightningSpeedCheck = gameTime;
      lightningSpeedBuffActiveUntil = gameTime + 3000; 
  }

  ctx.clearRect(0, 0, gameWidth, gameHeight);
  drawGrid();
  
  // ç¹ªè£½é»‘æ´
  for (let i = blackHoles.length - 1; i >= 0; i--) {
      blackHoles[i].draw();
      if (blackHoles[i].update()) {
          blackHoles.splice(i, 1);
      }
  }

  drawCastle();
  
  if ((wave === 5 || wave === 10) && enemies.some(e => e.type.isBoss)) {
    if (gameTime - lastMinionSpawn >= 5000) { 
      for (let i = 0; i < 2; i++) spawnMinion();
      lastMinionSpawn = gameTime;
    }
  }
  
  drawTowerRange(selectedTower);

  if (waveEnemies > 0 && waveSpawned < waveEnemies) {
    if (gameTime >= nextSpawnAt) {
      spawnEnemy(); 
      const gap = Math.max(260, (spawnIntervalBase - wave * 10)); 
      nextSpawnAt = gameTime + gap;
    }
  } else if (waveEnemies > 0 && enemies.length === 0 && waveSpawned >= waveEnemies) {
    wave++; startWave();
  }

  for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (!e || e.hp <= 0) enemies.splice(i, 1);
      else if (e.update()) enemies.splice(i, 1);
  }
  
  if (gameTime < towersStunnedUntil) {
  } else {
      towers.forEach(t => t.update());
  }
  
  for (let i = projectiles.length - 1; i >= 0; i--) {
      if (projectiles[i].update()) projectiles.splice(i, 1);
  }

  towers.forEach(t => { if (t !== draggingTower) t.draw(); });
  enemies.forEach(e => e.draw());
  projectiles.forEach(p => p.draw());

  if (gameTime < towersStunnedUntil) {
      towers.forEach(t => {
          const centerX = (t.x * TILE) + (TILE / 2);
          const centerY = (t.y * TILE) + (TILE / 2);
          ctx.font = `${TILE * 0.8}px Arial`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.fillText('ğŸš«', centerX, centerY);
      });
  }

  if (dragging && draggingTower) {
    const drawX = mouse.x - offsetX; 
    const drawY = mouse.y - offsetY;
    let drawSize = (draggingTower.subSlot !== null) ? (TILE / 2) : TILE;

    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
    ctx.fillRect(drawX - drawSize / 2, drawY - drawSize / 2, drawSize, drawSize);
    ctx.fillStyle = draggingTower.color; const ins = 3;
    ctx.fillRect(drawX - drawSize / 2 + ins, drawY - drawSize / 2 + ins, drawSize - 2 * ins, drawSize - 2 * ins);
    
    const dragFontSize = drawSize * Math.max(0.3, 0.8 - draggingTower.stars * 0.1);
    ctx.font = `${dragFontSize}px Arial`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillStyle = (draggingTower.type.name === 'ğŸ’°é‡‘å¹£å¡”') ? '#000000' : '#FFFFFF'; 
    const padding = drawSize * 0.1; 
    ctx.fillText(draggingTower.emoji.repeat(draggingTower.stars), drawX, drawY, drawSize - padding);
  }

  gameLoopId = requestAnimationFrame(loop);
}

resize(); 
</script>

<script>
/* ==============================================
 * ä¸»é¸å–®é‚è¼¯
 * ============================================== */
document.addEventListener('DOMContentLoaded', () => {

  const screens = {
    deckScreen: document.getElementById('deckScreen'),
    homeScreen: document.getElementById('homeScreen'),
    tacticsScreen: document.getElementById('tacticsScreen')
  };
  const navButtons = document.querySelectorAll('.navBtn');
  const startGameBtn = document.getElementById('startGameBtn');
  const availableTowersContainer = document.getElementById('availableTowers');
  const battleDeckContainer = document.getElementById('battleDeck');
  const tacticListContainer = document.getElementById('tacticList');
  const menuMessage = document.getElementById('menuMessage');
  
  let currentScreen = 'homeScreen';
  let draggedCard = null;
  
  const allTactics = [
    { id: 'archer_boss', name: 'ç¥å°„æ‰‹', desc: 'æ‰€æœ‰ä¸€æ˜ŸğŸ¹å¼“ç®­å¡”æ¯æ¬¡æ”»æ“Šå‘½ä¸­Bossæ™‚éƒ½æœƒ +$654321 é‡‘å¹£ã€‚' },
    { id: 'magic_buff', name: 'é­”åŠ›æ¹§å‹•', desc: 'æ‰€æœ‰ä¸€æ˜Ÿâœ¨é­”æ³•å¡”çš„æ”»é€Ÿå’Œæ”»æ“ŠåŠ›æå‡ 70%ã€‚' },
    { id: 'cannon_kill', name: 'ç«åŠ›å£“åˆ¶', desc: 'æ‰€æœ‰ä¸€æ˜ŸğŸ’£ç‚®å¡”æ¯æ“Šæ®ºä¸€å€‹æ•µäººï¼Œæ‰€æœ‰ä¸€æ˜Ÿç‚®å¡”åœ¨æœ¬å±€ä¸­æ°¸ä¹… +3% æ”»æ“ŠåŠ›ã€‚' },
    { id: 'lightning_speed', name: 'è¶…è¼‰', desc: 'æ‰€æœ‰ä¸€æ˜Ÿâš¡é›·å¡”çš„åŸºç¤æ”»é€Ÿè®Šç‚º 0.2 ç§’ã€‚' },
    { id: 'gold_rush', name: 'æ·˜é‡‘ç†± / éŠé‡‘è¡“', desc: 'æ¯å€‹ä¸€æ˜ŸğŸ’°é‡‘å¹£å¡”éƒ½èƒ½ç‚ºæ¯æ³¢+$1é‡‘å¹£ã€‚' },
    { id: 'confidence', name: 'è‡ªä¿¡å¿ƒ', desc: 'æ‰€æœ‰ä¸€æ˜ŸâœŒï¸å¿…å‹å¡”çš„æ”»æ“Šç‚ºå‘½ä¸­æ€ªç‰©æœ€å¤§ç”Ÿå‘½å€¼çš„5%ï¼Œæ”»é€Ÿç‚ºæ¯2ç§’ä¸€ä¸‹ï¼Œå°„ç¨‹ç‚º2æ ¼ã€‚' },
    { id: 'i_love_you', name: 'æˆ‘æ„›ä½ ', desc: 'æ¯æ”¾ç½®ä¸€å€‹ä¸€æ˜Ÿâ¤ï¸ç”Ÿå‘½å¡”ï¼Œç«‹å³æ¢å¾©åœ‹ç‹ 3 é»è¡€é‡ã€‚' },
    { id: 'cheer_splash', name: 'åŠ æ²¹åŠªåŠ›', desc: 'æ¯å€‹ä¸€æ˜ŸğŸ‘é¼“å‹µå¡”éƒ½èƒ½ç‚ºå…¶ä»–å¡”çš„å°„ç¨‹å’ŒsplashåŠ 1ã€‚' },
    { id: 'none', name: 'ç„¡æˆ°è¡“', desc: 'ä¾é ä½ è‡ªå·±çš„å¯¦åŠ›ï¼(é¦–æ¬¡åŸå ¡ğŸ°æŠ€èƒ½ $1000)' }
  ];

  function initMenu() {
    availableTowersContainer.innerHTML = '';
    window.towerTypes.forEach(tower => { 
      const card = createTowerCard(tower);
      availableTowersContainer.appendChild(card);
    });

    tacticListContainer.innerHTML = '';
    allTactics.forEach(tactic => {
      const card = createTacticCard(tactic);
      tacticListContainer.appendChild(card);
    });
    
    tacticListContainer.querySelector('.tactic-card[data-tactic-id="none"]').classList.add('selected');
  }

  function createTowerCard(tower) {
    const card = document.createElement('div');
    card.className = 'deck-card';
    card.draggable = true;
    card.dataset.towerName = tower.name;
    
    let displayPower = tower.baseDmg;
    let powerClass = ''; 
    
    if (tower.name === 'âœŒï¸å¿…å‹å¡”' || tower.name === 'ğŸ‘é¼“å‹µå¡”' || tower.name === 'ğŸ’°é‡‘å¹£å¡”') { 
        displayPower = 0;
    }
    if (tower.name === 'â¤ï¸ç”Ÿå‘½å¡”') {
        displayPower = -1000;
        powerClass = ' life'; 
    }
    if (tower.name === 'ğŸ‘é¼“å‹µå¡”') {
        powerClass = ' encourage';
    }
    if (tower.name === 'ğŸ’°é‡‘å¹£å¡”') {
        powerClass = ' gold';
    }
    
    card.innerHTML = `
      <div class="card-power${powerClass}">${displayPower}</div>
      <div class="card-emoji">${tower.emoji}</div>
      <div class="card-name">${tower.name}</div>
    `;
    card.addEventListener('dragstart', (e) => {
      draggedCard = e.target;
      setTimeout(() => e.target.style.opacity = 0.5, 0);
    });
    card.addEventListener('dragend', (e) => {
      draggedCard = null;
      e.target.style.opacity = 1;
    });
    return card;
  }
  
  function createTacticCard(tactic) {
    const card = document.createElement('div');
    card.className = 'tactic-card';
    card.dataset.tacticId = tactic.id;
    card.innerHTML = `
      <h3>${tactic.name}</h3>
      <p>${tactic.desc}</p>
    `;
    card.addEventListener('click', () => {
      tacticListContainer.querySelectorAll('.tactic-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
    });
    return card;
  }

  navButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const screenName = btn.dataset.screen;
      if (screenName === currentScreen) return;
      
      if (screens[currentScreen]) screens[currentScreen].style.display = 'none';
      navButtons.forEach(b => b.classList.remove('active'));
      
      if (screens[screenName]) screens[screenName].style.display = 'flex';
      btn.classList.add('active');
      
      currentScreen = screenName;
    });
  });
  
  const deckSlots = document.querySelectorAll('.deck-slot');
  
  deckSlots.forEach(slot => {
    slot.addEventListener('dragover', (e) => {
      e.preventDefault(); 
      slot.classList.add('drag-over');
    });
    slot.addEventListener('dragleave', (e) => {
      slot.classList.remove('drag-over');
    });
    slot.addEventListener('drop', (e) => {
      e.preventDefault();
      slot.classList.remove('drag-over');
      
      if (draggedCard && !slot.hasChildNodes()) { 
        const towerName = draggedCard.dataset.towerName;
        let inDeck = false;
        battleDeckContainer.querySelectorAll('.deck-card').forEach(card => {
          if (card.dataset.towerName === towerName) inDeck = true;
        });
        
        if (inDeck) {
          showMenuMessage("é€™å€‹å¡”å·²ç¶“åœ¨ç‰Œçµ„ä¸­äº†ï¼");
          return;
        }
        
        const newCard = draggedCard.cloneNode(true);
        newCard.draggable = false; 
        newCard.style.opacity = 1;
        newCard.style.cursor = 'default';
        newCard.addEventListener('click', () => {
          slot.innerHTML = ''; 
        });
        slot.innerHTML = ''; 
        slot.appendChild(newCard);
      }
    });
  });

  availableTowersContainer.addEventListener('dragover', (e) => e.preventDefault());
  availableTowersContainer.addEventListener('drop', (e) => { e.preventDefault(); });

  startGameBtn.addEventListener('click', () => {
    const selectedCards = Array.from(battleDeckContainer.querySelectorAll('.deck-card'));
    if (selectedCards.length < 4) {
        const deckButton = document.querySelector('.navBtn[data-screen="deckScreen"]');
        if (deckButton) {
            deckButton.click(); 
        }
        return;
    }
    
    window.selectedDeckTypes = selectedCards.map(cardEl => {
        const towerName = cardEl.dataset.towerName;
        return window.towerTypes.find(t => t.name === towerName); 
    });

    const selectedTacticEl = document.querySelector('#tacticsScreen .tactic-card.selected');
    if (selectedTacticEl) {
        window.activeTactic = allTactics.find(t => t.id === selectedTacticEl.dataset.tacticId);
    } else {
        window.activeTactic = allTactics.find(t => t.id === 'none'); 
    }

    window.guaranteedFirstTowerType = null;
    window.castleCostTacticApplied = false;

    if (window.activeTactic) {
        switch (window.activeTactic.id) {
            case 'archer_boss': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'ğŸ¹å¼“ç®­å¡”'); break;
            case 'magic_buff': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'âœ¨é­”æ³•å¡”'); break;
            case 'cannon_kill': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'ğŸ’£ç‚®å¡”'); break;
            case 'lightning_speed': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'âš¡é›·å¡”'); break;
            case 'gold_rush': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'ğŸ’°é‡‘å¹£å¡”'); break;
            case 'confidence': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'âœŒï¸å¿…å‹å¡”'); break;
            case 'i_love_you': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'â¤ï¸ç”Ÿå‘½å¡”'); break;
            case 'cheer_splash': window.guaranteedFirstTowerType = window.towerTypes.find(t => t.name === 'ğŸ‘é¼“å‹µå¡”'); break;
            case 'none': window.castleCostTacticApplied = true; break;
        }
    }

    window.tacticCannonKills = 0;
    
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('game').style.display = 'flex';
    
    gameSpeed = 1;
    speedBtn.textContent = '1x';
    speedBtn.style.background = 'linear-gradient(145deg, #ff4444, #cc3333)';

    gold = 5001; wave = 1; hp = 31; maxHp = 30; 
    towers = []; enemies = []; projectiles = [];
    placeIndex = 0; skillIndex = 0; nextMonstersHalfHp = 0;
    monsterStunTime = 0; 
    // (Removed monsterRewindTime)
    selectedTower = null; potentialDrag = null; draggingTower = null; dragging = false;
    lastMinionSpawn = 0; gameTime = 0; lastRealTime = 0;
    lastLightningSpeedCheck = 0; lightningSpeedBuffActiveUntil = 0;
    freeCastleCharges = 0; 
    
    kingRegenPerWave = 0;
    enemyHpDebuff = 0;
    kingShieldCharges = 0;
    hasKingShield = false;
    
    // éš¨æ©Ÿé¼“èˆé‡ç½®
    inspiredBuffs = [];
    nextInspireTime = 0;
    globalBuffs = { atkBuff: 0, rangeBuff: 0, splashBuff: 0, speedBuff1Star: 0 };

    fixedCostActive = false;
    victoryInstant3StarCharges = 0;
    blackHoles = [];
    bossHpOverride = 0;

    learnedSkillsRegistry.clear(); 
    slots = []; 
    
    resize(); 
    
    updateUI(); 
    startWave();
    
    setTimeout(() => {
        updateCosts();
        const currentSlots = getCastleSlots();
        const slotPixelY = currentSlots.length > 0 ? currentSlots[0].y * TILE : (gameHeight * BASELINE_Y);
        positionBottomControls(slotPixelY, gameHeight - slotPixelY);
    }, 100);

    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoopId = requestAnimationFrame(loop);
  });
  
  function showMenuMessage(msg) {
    menuMessage.textContent = msg;
    menuMessage.style.display = 'block';
    setTimeout(() => {
      menuMessage.style.display = 'none';
    }, 2500);
  }

  window.resetMenuUI = () => {
    deckSlots.forEach(slot => slot.innerHTML = '');
    tacticListContainer.querySelectorAll('.tactic-card').forEach(c => c.classList.remove('selected'));
    tacticListContainer.querySelector('.tactic-card[data-tactic-id="none"]').classList.add('selected');
    navButtons.forEach(btn => {
      const screenName = btn.dataset.screen;
      if (screenName === 'homeScreen') {
        btn.classList.add('active');
        screens[screenName].style.display = 'flex';
      } else {
        btn.classList.remove('active');
        screens[screenName].style.display = 'none';
      }
    });
    currentScreen = 'homeScreen';
  };

  initMenu();

});
</script>

</body>
</html>